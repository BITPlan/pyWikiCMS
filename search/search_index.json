{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyWikiCMS API Documentation","text":""},{"location":"#frontend.clickstream","title":"<code>clickstream</code>","text":"<p>Created on 2023-06-11</p> <p>@author: wf</p>"},{"location":"#frontend.clickstream.ClickStream","title":"<code>ClickStream</code>  <code>dataclass</code>","text":"<p>Represents a clickstream with associated page hits and user agent data.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass ClickStream:\n    \"\"\"Represents a clickstream with associated page hits and user agent data.\"\"\"\n\n    url: str\n    ip: str\n    domain: str\n    timeStamp: datetime\n    pageHits: List[PageHit]\n    userAgent: UserAgent\n    userAgentHeader: Optional[str] = None\n    referrer: Optional[str] = None\n    acceptLanguage: Optional[str] = None\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"ClickStream\":\n        data[\"timeStamp\"] = DateParse.parse_date(data[\"timeStamp\"])\n        # Ensure `pageHits` are processed into PageHit instances\n        # Initialize an empty list to store PageHit instances.\n        page_hits = []\n\n        # Iterate through each item in the list obtained from the 'pageHits' key.\n        # Using .get() with a default empty list to handle the absence of 'pageHits'.\n        for hit in data.get(\"pageHits\", []):\n            # Check if the current hit is not None before processing.\n            if hit is not None:\n                # Convert the hit dictionary to a PageHit instance and add it to the list.\n                page_hits.append(PageHit.from_dict(hit))\n\n        # 'data' dictionary is updated to hold the list of PageHit instances.\n        data[\"pageHits\"] = page_hits\n        # Remove any keys from `data` that are not fields of the `ClickStream` dataclass\n        # data = {key: value for key, value in data.items() if key in ClickStream.__annotations__}\n\n        # Let the `_postprocess` handle the userAgent conversion\n        data = ClickStream._postprocess(data)\n        return ClickStream(**data)\n\n    @staticmethod\n    def _postprocess(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        # Ensure `userAgent` is a dictionary before trying to convert\n        if isinstance(data.get(\"userAgent\"), dict):\n            data[\"userAgent\"] = UserAgent.from_dict(data[\"userAgent\"])\n        # If `pageHits` needs to be processed again (not typically necessary if handled in `from_dict`)\n        if isinstance(data.get(\"pageHits\"), list):\n            data[\"pageHits\"] = [\n                PageHit.from_dict(hit) if isinstance(hit, dict) else hit\n                for hit in data[\"pageHits\"]\n            ]\n        return data\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamLog","title":"<code>ClickstreamLog</code>  <code>dataclass</code>","text":"<p>single log of clickstreams</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass ClickstreamLog:\n    \"\"\"\n    single log of clickstreams\n    \"\"\"\n\n    debug: bool\n    MAX_CLICKSTREAMS: int\n    LOGGING_TIME_PERIOD: int\n    MAX_SESSION_TIME: int\n    FLUSH_PERIOD: int\n    startTime: datetime\n    lastFlush: datetime\n    lastLogRotate: datetime\n    fileName: str\n    clickStreams: List[ClickStream]\n\n    @classmethod\n    def from_json(cls, json_file: str):\n        with open(json_file, \"r\", encoding=\"utf-8\") as file:\n            data = json.load(file)\n\n        # Handle nested structures\n        data = ClickstreamLog._postprocess(data)\n\n        return ClickstreamLog(**data)\n\n    @classmethod\n    def _postprocess(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        data[\"startTime\"] = DateParse.parse_date(data[\"startTime\"])\n        data[\"lastFlush\"] = DateParse.parse_date(data[\"lastFlush\"])\n        data[\"lastLogRotate\"] = DateParse.parse_date(data[\"lastLogRotate\"])\n        data[\"clickStreams\"] = [\n            ClickStream.from_dict(cs) for cs in data.get(\"clickStreams\", [])\n        ]\n        return data\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager","title":"<code>ClickstreamManager</code>","text":"<p>               Bases: <code>object</code></p> <p>logging of client clicks</p> Source code in <code>frontend/clickstream.py</code> <pre><code>class ClickstreamManager(object):\n    \"\"\"\n    logging of client clicks\n    \"\"\"\n\n    def __init__(\n        self,\n        root_path: str,\n        rdf_namespace: str = \"http://cms.bitplan.com/clickstream#\",\n        show_progress: bool = True,\n        verbose: bool = True,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            root_path (str): the root path\n            rdf_namespace (str): The base namespace URI for the RDF export.\n            show_progress (bool): If True, show progress.\n            verbose (bool): If True, print the output message.\n        \"\"\"\n        self.root_path = root_path\n        self.rdf_namespace = rdf_namespace\n        self.clickstream_logs: List[ClickstreamLog] = []\n        self.show_progress = show_progress\n        self.verbose = verbose\n\n    def get_progress(self, iterable, desc=\"Processing\"):\n        \"\"\"\n        Wrap an iterable with a progress bar if show_progress is True\n        \"\"\"\n        if self.show_progress:\n            return tqdm(iterable, desc=desc)\n        else:\n            return iterable\n\n    def load_clickstream_logs(self, limit: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Load all clickstream logs from the directory\n        \"\"\"\n        # Find all json files in the directory\n        json_files = glob.glob(os.path.join(self.root_path, \"*.json\"))\n        # If a limit is set, truncate the file list\n        if limit is not None:\n            json_files = json_files[:limit]\n\n        # Prepare tqdm iterator if required and tqdm is available\n        iterator = self.get_progress(json_files, desc=\"Loading Clickstream Logs\")\n\n        total_clickstreams = 0\n\n        # Load each file\n\n        for json_file in iterator:\n            try:\n                # Parse the JSON file into ClickstreamLog\n                clickstream_log = ClickstreamLog.from_json(json_file)\n                self.clickstream_logs.append(clickstream_log)\n                total_clickstreams += len(\n                    clickstream_log.clickStreams\n                )  # Count the clickstreams\n            except json.JSONDecodeError as jde:\n                # Handle JSON-specific parsing errors\n                print(f\"JSON decode error in file {json_file}: {jde.msg}\")\n                print(f\"Error at line {jde.lineno}, column {jde.colno}\")\n            except Exception as e:\n                tb = traceback.format_exc()  # This will give you the stack trace\n                print(f\"Error loading {json_file}: {e}\")\n                print(tb)  # Print stack trace to get more details about the exception\n        # After importing, show the total counts\n        total_logs = len(self.clickstream_logs)\n        print(\n            f\"Imported {total_logs} clickstream logs with a total of {total_clickstreams} clickstreams.\"\n        )\n\n    def serialize_batch(\n        self, g: Graph, rdf_file: str, file_counter: int, rdf_format: str\n    ) -&gt; None:\n        \"\"\"\n        Serializes a batch of RDF data to a file.\n\n        Args:\n            g (Graph): The RDF graph to serialize.\n            rdf_file (str): The base name for the RDF file.\n            file_counter (int): The current file count for naming.\n            rdf_format (str): The format to serialize the RDF data.\n\n        \"\"\"\n        batch_file = f\"{rdf_file}_part{file_counter:03}.{rdf_format}\"\n        g.serialize(destination=batch_file, format=rdf_format)\n        if self.verbose:\n            print(f\"Exported RDF to {batch_file}\")\n\n    def add_stream_properties_to_graph(\n        self, g: Graph, CS: Namespace, stream: Any, entity_counter: int\n    ) -&gt; int:\n        \"\"\"\n        Adds the properties of a clickstream to the RDF graph.\n\n        Args:\n            g (Graph): The graph to which the properties will be added.\n            CS (Namespace): The namespace for clickstream data.\n            stream (Any): The clickstream object containing the data.\n            entity_counter (int): A counter for creating unique entities.\n\n        Returns:\n            int: The updated entity counter after adding the properties.\n        \"\"\"\n        stream_uri = URIRef(f\"{CS}clickstream/{entity_counter}\")\n        entity_counter += 1\n\n        # Add properties to the stream URI\n        g.add((stream_uri, RDF.type, CS.ClickStream))\n        g.add((stream_uri, CS.url, Literal(stream.url)))\n        g.add((stream_uri, CS.ip, Literal(stream.ip)))\n        g.add((stream_uri, CS.domain, Literal(stream.domain)))\n        g.add((stream_uri, CS.userAgentHeader, Literal(stream.userAgentHeader)))\n        g.add(\n            (\n                stream_uri,\n                CS.timeStamp,\n                Literal(stream.timeStamp.isoformat(), datatype=XSD.dateTime),\n            )\n        )\n\n        # Optional referrer information\n        if stream.referrer:\n            g.add((stream_uri, CS.referrer, Literal(stream.referrer)))\n\n        # User Agent details\n        ua_uri = URIRef(f\"{CS}useragent/{entity_counter}\")\n        entity_counter += 1\n        g.add((ua_uri, RDF.type, CS.UserAgent))\n        g.add((ua_uri, CS.hasSyntaxError, Literal(stream.userAgent.hasSyntaxError)))\n        g.add((ua_uri, CS.hasAmbiguity, Literal(stream.userAgent.hasAmbiguity)))\n        g.add((ua_uri, CS.ambiguityCount, Literal(stream.userAgent.ambiguityCount)))\n        g.add((ua_uri, CS.userAgentString, Literal(stream.userAgent.userAgentString)))\n        g.add((stream_uri, CS.userAgent, ua_uri))\n\n        # Page Hits\n        for hit in stream.pageHits:\n            hit_uri = URIRef(f\"{CS}pagehit/{entity_counter}\")\n            entity_counter += 1\n            g.add((hit_uri, RDF.type, CS.PageHit))\n            g.add((hit_uri, CS.path, Literal(hit.path)))\n            g.add(\n                (\n                    hit_uri,\n                    CS.timeStamp,\n                    Literal(hit.timeStamp.isoformat(), datatype=XSD.dateTime),\n                )\n            )\n            g.add((stream_uri, CS.pageHits, hit_uri))\n\n        return entity_counter\n\n    def export_to_rdf(\n        self,\n        rdf_file: str,\n        batch_size: int,\n        rdf_format: str = \"nt\",\n    ) -&gt; None:\n        \"\"\"\n        Export clickstream logs to RDF files in batches.\n        :param rdf_file: The base file name to write the RDF data to.\n        :param batch_size: The number of clickstream records per file.\n        :param rdf_format: The RDF serialization format to use (default is \"nt\").\n        \"\"\"\n        # Namespace definition\n        CS = Namespace(self.rdf_namespace)\n\n        # Initialize variables\n        file_counter = 1\n        entity_counter = 1\n        g = Graph()\n        g.bind(\"cs\", CS)\n\n        # Create the directory if it doesn't exist\n        os.makedirs(os.path.dirname(rdf_file), exist_ok=True)\n        iterator = self.get_progress(self.clickstream_logs, desc=\"Export Progress\")\n\n        for log in iterator:\n            for stream in log.clickStreams:\n                entity_counter = self.add_stream_properties_to_graph(\n                    g, CS, stream, entity_counter\n                )\n\n                # If batch size is reached, serialize and save to file\n                if entity_counter % batch_size == 0:\n                    self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n                    file_counter += 1\n                    g = Graph()  # Reset the graph for the next batch\n                    g.bind(\"cs\", CS)\n\n        # Serialize and save any remaining triples that didn't fill up the last batch\n        if len(g):\n            self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n\n    def reload_graph(self, rdf_file_pattern: str, rdf_format: str = \"nt\") -&gt; Graph:\n        \"\"\"\n        Reloads the RDF data from a batch of files into the clickstream logs.\n\n        Args:\n            rdf_file_pattern (str): The file pattern to search for RDF files.\n                                    A wildcard '*' will be appended if not present.\n            rdf_format (str): The RDF serialization format of the files (default is \"nt\").\n\n        Returns:\n            Graph: The RDF graph populated with data from the files.\n        \"\"\"\n        # Ensure the pattern ends with a wildcard, append if necessary\n        if not rdf_file_pattern.endswith(\"*\"):\n            rdf_file_pattern += \"*\"\n\n        # Find all files matching the pattern\n        rdf_files = glob.glob(rdf_file_pattern)\n\n        # Initialize a new RDF graph\n        g = Graph()\n\n        # Use a progress bar if available or simply iterate over files\n        try:\n            iterator = self.get_progress(rdf_files, desc=\"Loading graph\")\n        except AttributeError:\n            # If get_progress is not defined, fall back to simple iteration\n            iterator = rdf_files\n\n        for rdf_file in iterator:\n            # Parse each RDF file and add it to the graph\n            g.parse(rdf_file, format=rdf_format)\n\n        # After loading all files, return the populated graph\n        return g\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.__init__","title":"<code>__init__(root_path, rdf_namespace='http://cms.bitplan.com/clickstream#', show_progress=True, verbose=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>root_path</code> <code>str</code> <p>the root path</p> required <code>rdf_namespace</code> <code>str</code> <p>The base namespace URI for the RDF export.</p> <code>'http://cms.bitplan.com/clickstream#'</code> <code>show_progress</code> <code>bool</code> <p>If True, show progress.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>If True, print the output message.</p> <code>True</code> Source code in <code>frontend/clickstream.py</code> <pre><code>def __init__(\n    self,\n    root_path: str,\n    rdf_namespace: str = \"http://cms.bitplan.com/clickstream#\",\n    show_progress: bool = True,\n    verbose: bool = True,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        root_path (str): the root path\n        rdf_namespace (str): The base namespace URI for the RDF export.\n        show_progress (bool): If True, show progress.\n        verbose (bool): If True, print the output message.\n    \"\"\"\n    self.root_path = root_path\n    self.rdf_namespace = rdf_namespace\n    self.clickstream_logs: List[ClickstreamLog] = []\n    self.show_progress = show_progress\n    self.verbose = verbose\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.add_stream_properties_to_graph","title":"<code>add_stream_properties_to_graph(g, CS, stream, entity_counter)</code>","text":"<p>Adds the properties of a clickstream to the RDF graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Graph</code> <p>The graph to which the properties will be added.</p> required <code>CS</code> <code>Namespace</code> <p>The namespace for clickstream data.</p> required <code>stream</code> <code>Any</code> <p>The clickstream object containing the data.</p> required <code>entity_counter</code> <code>int</code> <p>A counter for creating unique entities.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The updated entity counter after adding the properties.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def add_stream_properties_to_graph(\n    self, g: Graph, CS: Namespace, stream: Any, entity_counter: int\n) -&gt; int:\n    \"\"\"\n    Adds the properties of a clickstream to the RDF graph.\n\n    Args:\n        g (Graph): The graph to which the properties will be added.\n        CS (Namespace): The namespace for clickstream data.\n        stream (Any): The clickstream object containing the data.\n        entity_counter (int): A counter for creating unique entities.\n\n    Returns:\n        int: The updated entity counter after adding the properties.\n    \"\"\"\n    stream_uri = URIRef(f\"{CS}clickstream/{entity_counter}\")\n    entity_counter += 1\n\n    # Add properties to the stream URI\n    g.add((stream_uri, RDF.type, CS.ClickStream))\n    g.add((stream_uri, CS.url, Literal(stream.url)))\n    g.add((stream_uri, CS.ip, Literal(stream.ip)))\n    g.add((stream_uri, CS.domain, Literal(stream.domain)))\n    g.add((stream_uri, CS.userAgentHeader, Literal(stream.userAgentHeader)))\n    g.add(\n        (\n            stream_uri,\n            CS.timeStamp,\n            Literal(stream.timeStamp.isoformat(), datatype=XSD.dateTime),\n        )\n    )\n\n    # Optional referrer information\n    if stream.referrer:\n        g.add((stream_uri, CS.referrer, Literal(stream.referrer)))\n\n    # User Agent details\n    ua_uri = URIRef(f\"{CS}useragent/{entity_counter}\")\n    entity_counter += 1\n    g.add((ua_uri, RDF.type, CS.UserAgent))\n    g.add((ua_uri, CS.hasSyntaxError, Literal(stream.userAgent.hasSyntaxError)))\n    g.add((ua_uri, CS.hasAmbiguity, Literal(stream.userAgent.hasAmbiguity)))\n    g.add((ua_uri, CS.ambiguityCount, Literal(stream.userAgent.ambiguityCount)))\n    g.add((ua_uri, CS.userAgentString, Literal(stream.userAgent.userAgentString)))\n    g.add((stream_uri, CS.userAgent, ua_uri))\n\n    # Page Hits\n    for hit in stream.pageHits:\n        hit_uri = URIRef(f\"{CS}pagehit/{entity_counter}\")\n        entity_counter += 1\n        g.add((hit_uri, RDF.type, CS.PageHit))\n        g.add((hit_uri, CS.path, Literal(hit.path)))\n        g.add(\n            (\n                hit_uri,\n                CS.timeStamp,\n                Literal(hit.timeStamp.isoformat(), datatype=XSD.dateTime),\n            )\n        )\n        g.add((stream_uri, CS.pageHits, hit_uri))\n\n    return entity_counter\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.export_to_rdf","title":"<code>export_to_rdf(rdf_file, batch_size, rdf_format='nt')</code>","text":"<p>Export clickstream logs to RDF files in batches. :param rdf_file: The base file name to write the RDF data to. :param batch_size: The number of clickstream records per file. :param rdf_format: The RDF serialization format to use (default is \"nt\").</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def export_to_rdf(\n    self,\n    rdf_file: str,\n    batch_size: int,\n    rdf_format: str = \"nt\",\n) -&gt; None:\n    \"\"\"\n    Export clickstream logs to RDF files in batches.\n    :param rdf_file: The base file name to write the RDF data to.\n    :param batch_size: The number of clickstream records per file.\n    :param rdf_format: The RDF serialization format to use (default is \"nt\").\n    \"\"\"\n    # Namespace definition\n    CS = Namespace(self.rdf_namespace)\n\n    # Initialize variables\n    file_counter = 1\n    entity_counter = 1\n    g = Graph()\n    g.bind(\"cs\", CS)\n\n    # Create the directory if it doesn't exist\n    os.makedirs(os.path.dirname(rdf_file), exist_ok=True)\n    iterator = self.get_progress(self.clickstream_logs, desc=\"Export Progress\")\n\n    for log in iterator:\n        for stream in log.clickStreams:\n            entity_counter = self.add_stream_properties_to_graph(\n                g, CS, stream, entity_counter\n            )\n\n            # If batch size is reached, serialize and save to file\n            if entity_counter % batch_size == 0:\n                self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n                file_counter += 1\n                g = Graph()  # Reset the graph for the next batch\n                g.bind(\"cs\", CS)\n\n    # Serialize and save any remaining triples that didn't fill up the last batch\n    if len(g):\n        self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.get_progress","title":"<code>get_progress(iterable, desc='Processing')</code>","text":"<p>Wrap an iterable with a progress bar if show_progress is True</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def get_progress(self, iterable, desc=\"Processing\"):\n    \"\"\"\n    Wrap an iterable with a progress bar if show_progress is True\n    \"\"\"\n    if self.show_progress:\n        return tqdm(iterable, desc=desc)\n    else:\n        return iterable\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.load_clickstream_logs","title":"<code>load_clickstream_logs(limit=None)</code>","text":"<p>Load all clickstream logs from the directory</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def load_clickstream_logs(self, limit: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Load all clickstream logs from the directory\n    \"\"\"\n    # Find all json files in the directory\n    json_files = glob.glob(os.path.join(self.root_path, \"*.json\"))\n    # If a limit is set, truncate the file list\n    if limit is not None:\n        json_files = json_files[:limit]\n\n    # Prepare tqdm iterator if required and tqdm is available\n    iterator = self.get_progress(json_files, desc=\"Loading Clickstream Logs\")\n\n    total_clickstreams = 0\n\n    # Load each file\n\n    for json_file in iterator:\n        try:\n            # Parse the JSON file into ClickstreamLog\n            clickstream_log = ClickstreamLog.from_json(json_file)\n            self.clickstream_logs.append(clickstream_log)\n            total_clickstreams += len(\n                clickstream_log.clickStreams\n            )  # Count the clickstreams\n        except json.JSONDecodeError as jde:\n            # Handle JSON-specific parsing errors\n            print(f\"JSON decode error in file {json_file}: {jde.msg}\")\n            print(f\"Error at line {jde.lineno}, column {jde.colno}\")\n        except Exception as e:\n            tb = traceback.format_exc()  # This will give you the stack trace\n            print(f\"Error loading {json_file}: {e}\")\n            print(tb)  # Print stack trace to get more details about the exception\n    # After importing, show the total counts\n    total_logs = len(self.clickstream_logs)\n    print(\n        f\"Imported {total_logs} clickstream logs with a total of {total_clickstreams} clickstreams.\"\n    )\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.reload_graph","title":"<code>reload_graph(rdf_file_pattern, rdf_format='nt')</code>","text":"<p>Reloads the RDF data from a batch of files into the clickstream logs.</p> <p>Parameters:</p> Name Type Description Default <code>rdf_file_pattern</code> <code>str</code> <p>The file pattern to search for RDF files.                     A wildcard '*' will be appended if not present.</p> required <code>rdf_format</code> <code>str</code> <p>The RDF serialization format of the files (default is \"nt\").</p> <code>'nt'</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>Graph</code> <p>The RDF graph populated with data from the files.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def reload_graph(self, rdf_file_pattern: str, rdf_format: str = \"nt\") -&gt; Graph:\n    \"\"\"\n    Reloads the RDF data from a batch of files into the clickstream logs.\n\n    Args:\n        rdf_file_pattern (str): The file pattern to search for RDF files.\n                                A wildcard '*' will be appended if not present.\n        rdf_format (str): The RDF serialization format of the files (default is \"nt\").\n\n    Returns:\n        Graph: The RDF graph populated with data from the files.\n    \"\"\"\n    # Ensure the pattern ends with a wildcard, append if necessary\n    if not rdf_file_pattern.endswith(\"*\"):\n        rdf_file_pattern += \"*\"\n\n    # Find all files matching the pattern\n    rdf_files = glob.glob(rdf_file_pattern)\n\n    # Initialize a new RDF graph\n    g = Graph()\n\n    # Use a progress bar if available or simply iterate over files\n    try:\n        iterator = self.get_progress(rdf_files, desc=\"Loading graph\")\n    except AttributeError:\n        # If get_progress is not defined, fall back to simple iteration\n        iterator = rdf_files\n\n    for rdf_file in iterator:\n        # Parse each RDF file and add it to the graph\n        g.parse(rdf_file, format=rdf_format)\n\n    # After loading all files, return the populated graph\n    return g\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.serialize_batch","title":"<code>serialize_batch(g, rdf_file, file_counter, rdf_format)</code>","text":"<p>Serializes a batch of RDF data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Graph</code> <p>The RDF graph to serialize.</p> required <code>rdf_file</code> <code>str</code> <p>The base name for the RDF file.</p> required <code>file_counter</code> <code>int</code> <p>The current file count for naming.</p> required <code>rdf_format</code> <code>str</code> <p>The format to serialize the RDF data.</p> required Source code in <code>frontend/clickstream.py</code> <pre><code>def serialize_batch(\n    self, g: Graph, rdf_file: str, file_counter: int, rdf_format: str\n) -&gt; None:\n    \"\"\"\n    Serializes a batch of RDF data to a file.\n\n    Args:\n        g (Graph): The RDF graph to serialize.\n        rdf_file (str): The base name for the RDF file.\n        file_counter (int): The current file count for naming.\n        rdf_format (str): The format to serialize the RDF data.\n\n    \"\"\"\n    batch_file = f\"{rdf_file}_part{file_counter:03}.{rdf_format}\"\n    g.serialize(destination=batch_file, format=rdf_format)\n    if self.verbose:\n        print(f\"Exported RDF to {batch_file}\")\n</code></pre>"},{"location":"#frontend.clickstream.DateParse","title":"<code>DateParse</code>","text":"Source code in <code>frontend/clickstream.py</code> <pre><code>class DateParse:\n    @staticmethod\n    def parse_date(date_str: str) -&gt; datetime:\n        \"\"\"Parse a string to a datetime object.\n\n        Args:\n            date_str (str): The date string to parse.\n\n        Returns:\n            datetime: The parsed datetime object.\n        \"\"\"\n        return datetime.strptime(date_str, \"%b %d, %Y %I:%M:%S %p\")\n</code></pre>"},{"location":"#frontend.clickstream.DateParse.parse_date","title":"<code>parse_date(date_str)</code>  <code>staticmethod</code>","text":"<p>Parse a string to a datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to parse.</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The parsed datetime object.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@staticmethod\ndef parse_date(date_str: str) -&gt; datetime:\n    \"\"\"Parse a string to a datetime object.\n\n    Args:\n        date_str (str): The date string to parse.\n\n    Returns:\n        datetime: The parsed datetime object.\n    \"\"\"\n    return datetime.strptime(date_str, \"%b %d, %Y %I:%M:%S %p\")\n</code></pre>"},{"location":"#frontend.clickstream.PageHit","title":"<code>PageHit</code>  <code>dataclass</code>","text":"<p>Represents a single page hit with path and timestamp.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass PageHit:\n    \"\"\"Represents a single page hit with path and timestamp.\"\"\"\n\n    path: str\n    timeStamp: datetime\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"PageHit\":\n        data[\"timeStamp\"] = DateParse.parse_date(data[\"timeStamp\"])\n        return PageHit(**data)\n</code></pre>"},{"location":"#frontend.clickstream.UserAgent","title":"<code>UserAgent</code>  <code>dataclass</code>","text":"<p>Represents a user agent with syntax errors, ambiguity and other attributes.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass UserAgent:\n    \"\"\"Represents a user agent with syntax errors, ambiguity and other attributes.\"\"\"\n\n    hasSyntaxError: bool\n    hasAmbiguity: bool\n    ambiguityCount: int\n    userAgentString: str\n    debug: bool\n    allFields: Dict[str, Dict[str, Any]]\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"UserAgent\":\n        allFields = data.get(\"allFields\", {})\n\n        # Use `.get()` with defaults to prevent KeyError\n        return UserAgent(\n            hasSyntaxError=data.get(\"hasSyntaxError\", False),\n            hasAmbiguity=data.get(\"hasAmbiguity\", False),\n            ambiguityCount=data.get(\"ambiguityCount\", 0),\n            userAgentString=data.get(\"userAgentString\", \"\"),\n            debug=data.get(\"debug\", False),\n            allFields=allFields,\n        )\n</code></pre>"},{"location":"#frontend.cmsmain","title":"<code>cmsmain</code>","text":"<p>Created on 2022-11-24</p> <p>@author: wf</p>"},{"location":"#frontend.cmsmain.CmsMain","title":"<code>CmsMain</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>ContentManagement System Main Program</p> Source code in <code>frontend/cmsmain.py</code> <pre><code>class CmsMain(WebserverCmd):\n    \"\"\"\n    ContentManagement System Main Program\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"--sites\", nargs=\"+\", required=False, help=\"the sites to enable\"\n        )\n        return parser\n</code></pre>"},{"location":"#frontend.cmsmain.CmsMain.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>frontend/cmsmain.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"--sites\", nargs=\"+\", required=False, help=\"the sites to enable\"\n    )\n    return parser\n</code></pre>"},{"location":"#frontend.cmsmain.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>frontend/cmsmain.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = CmsMain(config=CmsWebServer.get_config(), webserver_cls=CmsWebServer)\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#frontend.frame","title":"<code>frame</code>","text":""},{"location":"#frontend.frame.HtmlFrame","title":"<code>HtmlFrame</code>","text":"<p>A class to frame html content with a basic HTML document structure.</p> <p>Attributes:</p> Name Type Description <code>lang</code> <code>str</code> <p>Language of the HTML document.</p> <code>title</code> <code>str</code> <p>Title of the HTML document.</p> Source code in <code>frontend/frame.py</code> <pre><code>class HtmlFrame:\n    \"\"\"\n    A class to frame html content with a basic HTML document structure.\n\n    Attributes:\n        lang (str): Language of the HTML document.\n        title (str): Title of the HTML document.\n    \"\"\"\n\n    def __init__(self, frontend, title: str, lang: str = \"en\") -&gt; None:\n        \"\"\"\n        Initialize HtmlFrame with a specified language and title.\n\n        Args:\n            title (str): Title for the HTML document.\n            lang (str, optional): Language of the HTML document. Defaults to \"en\".\n        \"\"\"\n        self.frontend = frontend\n        self.lang = lang\n        self.title = title\n\n    def hamburger_menu(self) -&gt; str:\n        \"\"\"\n        Generate the HTML, CSS, and JavaScript for a hamburger menu.\n\n        Returns:\n            str: Hamburger menu HTML, CSS, and JavaScript.\n        \"\"\"\n        menu_html = \"\"\"\n&lt;!-- Hamburger Menu Start --&gt;\n&lt;style&gt;\n  /* Basic styling */\n  .menu { display: none; }\n  .hamburger { cursor: pointer; }\n  .hamburger:hover { opacity: 0.7; }\n\n  /* Menu items layout */\n  .menu ul { list-style-type: none; padding: 0; }\n  .menu li { padding: 8px; background-color: #f0f0f0; margin-bottom: 5px; }\n\n  /* Show the menu when .show class is added via JavaScript */\n  .show { display: block; }\n&lt;/style&gt;\n\n&lt;!-- Hamburger Icon --&gt;\n&lt;div class=\"hamburger\" onclick=\"toggleMenu()\"&gt;\u2630&lt;/div&gt;\n\n&lt;!-- Menu Items --&gt;\n&lt;div class=\"menu\" id=\"mainMenu\"&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#services\"&gt;Services&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  function toggleMenu() {\n    var menu = document.getElementById(\"mainMenu\");\n    if (menu.classList.contains(\"show\")) {\n      menu.classList.remove(\"show\");\n    } else {\n      menu.classList.add(\"show\");\n    }\n  }\n&lt;/script&gt;\n&lt;!-- Hamburger Menu End --&gt;\n\"\"\"\n        return menu_html\n\n    def header(self) -&gt; str:\n        \"\"\"\n        Generate the header part of the HTML document.\n\n        Returns:\n            str: Header part of an HTML document as a string.\n        \"\"\"\n        style_key = f\"CMS/style\"\n        style_html = self.frontend.cms_pages.get(style_key, \"\")\n        html = f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\"{self.lang}\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"/&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;{self.title}&lt;/title&gt;\n  {style_html}\n&lt;/head&gt;\n&lt;body&gt;  \n\"\"\"\n        return html\n\n    def footer(self) -&gt; str:\n        \"\"\"\n        Generate the footer part of the HTML document.\n\n        Returns:\n            str: Footer part of an HTML document as a string.\n        \"\"\"\n        footer_key = f\"CMS/footer/{self.lang}\"\n        footer_html = self.frontend.cms_pages.get(footer_key, \"\")\n        html = f\"\"\"{footer_html}\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n        return html\n\n    def frame(self, content: str) -&gt; str:\n        \"\"\"\n        Frame the given HTML content with the header and footer of the document.\n\n        Args:\n            content (str): HTML content to be framed within the HTML structure.\n\n        Returns:\n            str: Complete HTML document as a string with the provided content framed.\n        \"\"\"\n        header_key = f\"CMS/header/{self.lang}\"\n        header_html = self.frontend.cms_pages.get(header_key, \"\")\n        html = f\"\"\"{self.header()}\n{self.hamburger_menu()}  \n{header_html}\n      &lt;div class=\"container\"&gt;\n{content}\n      &lt;/div&gt;&lt;!-- /.container --&gt;\n{self.footer()}\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.__init__","title":"<code>__init__(frontend, title, lang='en')</code>","text":"<p>Initialize HtmlFrame with a specified language and title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title for the HTML document.</p> required <code>lang</code> <code>str</code> <p>Language of the HTML document. Defaults to \"en\".</p> <code>'en'</code> Source code in <code>frontend/frame.py</code> <pre><code>def __init__(self, frontend, title: str, lang: str = \"en\") -&gt; None:\n    \"\"\"\n    Initialize HtmlFrame with a specified language and title.\n\n    Args:\n        title (str): Title for the HTML document.\n        lang (str, optional): Language of the HTML document. Defaults to \"en\".\n    \"\"\"\n    self.frontend = frontend\n    self.lang = lang\n    self.title = title\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.footer","title":"<code>footer()</code>","text":"<p>Generate the footer part of the HTML document.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Footer part of an HTML document as a string.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def footer(self) -&gt; str:\n        \"\"\"\n        Generate the footer part of the HTML document.\n\n        Returns:\n            str: Footer part of an HTML document as a string.\n        \"\"\"\n        footer_key = f\"CMS/footer/{self.lang}\"\n        footer_html = self.frontend.cms_pages.get(footer_key, \"\")\n        html = f\"\"\"{footer_html}\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.frame","title":"<code>frame(content)</code>","text":"<p>Frame the given HTML content with the header and footer of the document.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>HTML content to be framed within the HTML structure.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Complete HTML document as a string with the provided content framed.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def frame(self, content: str) -&gt; str:\n        \"\"\"\n        Frame the given HTML content with the header and footer of the document.\n\n        Args:\n            content (str): HTML content to be framed within the HTML structure.\n\n        Returns:\n            str: Complete HTML document as a string with the provided content framed.\n        \"\"\"\n        header_key = f\"CMS/header/{self.lang}\"\n        header_html = self.frontend.cms_pages.get(header_key, \"\")\n        html = f\"\"\"{self.header()}\n{self.hamburger_menu()}  \n{header_html}\n      &lt;div class=\"container\"&gt;\n{content}\n      &lt;/div&gt;&lt;!-- /.container --&gt;\n{self.footer()}\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.hamburger_menu","title":"<code>hamburger_menu()</code>","text":"<p>Generate the HTML, CSS, and JavaScript for a hamburger menu.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hamburger menu HTML, CSS, and JavaScript.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def hamburger_menu(self) -&gt; str:\n        \"\"\"\n        Generate the HTML, CSS, and JavaScript for a hamburger menu.\n\n        Returns:\n            str: Hamburger menu HTML, CSS, and JavaScript.\n        \"\"\"\n        menu_html = \"\"\"\n&lt;!-- Hamburger Menu Start --&gt;\n&lt;style&gt;\n  /* Basic styling */\n  .menu { display: none; }\n  .hamburger { cursor: pointer; }\n  .hamburger:hover { opacity: 0.7; }\n\n  /* Menu items layout */\n  .menu ul { list-style-type: none; padding: 0; }\n  .menu li { padding: 8px; background-color: #f0f0f0; margin-bottom: 5px; }\n\n  /* Show the menu when .show class is added via JavaScript */\n  .show { display: block; }\n&lt;/style&gt;\n\n&lt;!-- Hamburger Icon --&gt;\n&lt;div class=\"hamburger\" onclick=\"toggleMenu()\"&gt;\u2630&lt;/div&gt;\n\n&lt;!-- Menu Items --&gt;\n&lt;div class=\"menu\" id=\"mainMenu\"&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#services\"&gt;Services&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  function toggleMenu() {\n    var menu = document.getElementById(\"mainMenu\");\n    if (menu.classList.contains(\"show\")) {\n      menu.classList.remove(\"show\");\n    } else {\n      menu.classList.add(\"show\");\n    }\n  }\n&lt;/script&gt;\n&lt;!-- Hamburger Menu End --&gt;\n\"\"\"\n        return menu_html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.header","title":"<code>header()</code>","text":"<p>Generate the header part of the HTML document.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Header part of an HTML document as a string.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def header(self) -&gt; str:\n        \"\"\"\n        Generate the header part of the HTML document.\n\n        Returns:\n            str: Header part of an HTML document as a string.\n        \"\"\"\n        style_key = f\"CMS/style\"\n        style_html = self.frontend.cms_pages.get(style_key, \"\")\n        html = f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\"{self.lang}\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"/&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;{self.title}&lt;/title&gt;\n  {style_html}\n&lt;/head&gt;\n&lt;body&gt;  \n\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.html_table","title":"<code>html_table</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#frontend.html_table.HtmlTables","title":"<code>HtmlTables</code>","text":"<p>               Bases: <code>WebScrape</code></p> <p>HtmlTables extractor</p> Source code in <code>frontend/html_table.py</code> <pre><code>class HtmlTables(WebScrape):\n    \"\"\"\n    HtmlTables extractor\n    \"\"\"\n\n    def __init__(self, url: str, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n\n        url(str): the url to read the tables from\n        debug(bool): if True switch on debugging\n        showHtml(bool): if True show the HTML retrieved\n        \"\"\"\n        super().__init__(debug, showHtml)\n        self.soup = super().getSoup(url, showHtml)\n\n    def get_tables(self, header_tag: str = None) -&gt; dict:\n        \"\"\"\n        get all tables from my soup as a list of list of dicts\n\n        Args:\n            header_tag(str): if set search the table name from the given header tag\n\n        Return:\n            dict: the list of list of dicts for all tables\n\n        \"\"\"\n        tables = {}\n        for i, table in enumerate(self.soup.find_all(\"table\")):\n            fields = []\n            table_data = []\n            category = None\n            for tr in table.find_all(\"tr\", recursive=True):\n                for th in tr.find_all(\"th\", recursive=True):\n                    if \"colspan\" in th.attrs:\n                        category = th.text\n                    else:\n                        fields.append(th.text)\n            for tr in table.find_all(\"tr\", recursive=True):\n                record = {}\n                for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                    record[fields[i]] = td.text\n                if record:\n                    if category:\n                        record[\"category\"] = category\n                    table_data.append(record)\n            if header_tag is not None:\n                header = table.find_previous_sibling(header_tag)\n                table_name = header.text\n            else:\n                table_name = f\"table{i}\"\n            tables[table_name] = table_data\n        return tables\n</code></pre>"},{"location":"#frontend.html_table.HtmlTables.__init__","title":"<code>__init__(url, debug=False, showHtml=False)</code>","text":"<p>Constructor</p> <p>url(str): the url to read the tables from debug(bool): if True switch on debugging showHtml(bool): if True show the HTML retrieved</p> Source code in <code>frontend/html_table.py</code> <pre><code>def __init__(self, url: str, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n\n    url(str): the url to read the tables from\n    debug(bool): if True switch on debugging\n    showHtml(bool): if True show the HTML retrieved\n    \"\"\"\n    super().__init__(debug, showHtml)\n    self.soup = super().getSoup(url, showHtml)\n</code></pre>"},{"location":"#frontend.html_table.HtmlTables.get_tables","title":"<code>get_tables(header_tag=None)</code>","text":"<p>get all tables from my soup as a list of list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>header_tag(str)</code> <p>if set search the table name from the given header tag</p> required Return <p>dict: the list of list of dicts for all tables</p> Source code in <code>frontend/html_table.py</code> <pre><code>def get_tables(self, header_tag: str = None) -&gt; dict:\n    \"\"\"\n    get all tables from my soup as a list of list of dicts\n\n    Args:\n        header_tag(str): if set search the table name from the given header tag\n\n    Return:\n        dict: the list of list of dicts for all tables\n\n    \"\"\"\n    tables = {}\n    for i, table in enumerate(self.soup.find_all(\"table\")):\n        fields = []\n        table_data = []\n        category = None\n        for tr in table.find_all(\"tr\", recursive=True):\n            for th in tr.find_all(\"th\", recursive=True):\n                if \"colspan\" in th.attrs:\n                    category = th.text\n                else:\n                    fields.append(th.text)\n        for tr in table.find_all(\"tr\", recursive=True):\n            record = {}\n            for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                record[fields[i]] = td.text\n            if record:\n                if category:\n                    record[\"category\"] = category\n                table_data.append(record)\n        if header_tag is not None:\n            header = table.find_previous_sibling(header_tag)\n            table_name = header.text\n        else:\n            table_name = f\"table{i}\"\n        tables[table_name] = table_data\n    return tables\n</code></pre>"},{"location":"#frontend.mediawiki_site","title":"<code>mediawiki_site</code>","text":"<p>Created on 09.03.2025</p> <p>@author: wf</p>"},{"location":"#frontend.mediawiki_site.MediaWikiSite","title":"<code>MediaWikiSite</code>","text":"<p>a MediaWikiSite and it's current  state</p> Source code in <code>frontend/mediawiki_site.py</code> <pre><code>class MediaWikiSite:\n    \"\"\"\n    a MediaWikiSite and it's current  state\n    \"\"\"\n\n    def __init__(\n        self,\n        wiki_user: WikiUser,\n        row_index: int = 0,\n        debug: bool = False,\n        show_html: bool = False,\n    ):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.row_no = row_index + 1\n        self.wiki_user = wiki_user\n        self.wiki_url = self.wiki_user.url\n        self.debug = debug\n        self.show_html = show_html\n        self.wiki_backup = WikiBackup(wiki_user)\n        self._wiki_client = None\n        self.task_runner = TaskRunner()\n\n    @property\n    def wiki_client(self) -&gt; WikiClient:\n        if not self._wiki_client:\n            client = WikiClient.ofWikiUser(self.wiki_user)\n            if client.needs_login:\n                client.login()\n            self._wiki_client = client\n        return self._wiki_client\n\n    def as_dict(self):\n        url = f\"{self.wiki_user.url}{self.wiki_user.scriptPath}\"\n        link = Link.create(url=url, text=self.wiki_user.wikiId, target=\"_blank\")\n\n        record = {\n            \"#\": self.row_no,\n            \"wiki\": link,\n            \"version\": self.wiki_user.version,\n            \"pages\": \"\",\n            \"backup\": \"\u2705\" if self.wiki_backup.exists() else \"\u274c\",\n            \"git\": \"\u2705\" if self.wiki_backup.hasGit() else \"\u274c\",\n            \"age\": \"\",\n            \"login\": \"\",\n        }\n        return record\n\n    def get_software_version_map(\n        self, tables: Dict[str, List[Dict[str, Any]]]\n    ) -&gt; Optional[Dict[str, Dict[str, Any]]]:\n        \"\"\"\n        Extract software map from the Special:Version tables.\n\n        Args:\n            tables (Dict[str, List[Dict[str, Any]]]): Dictionary of tables with their headers as keys.\n\n        Returns:\n            Optional[Dict[str, Dict[str, Any]]]: A dictionary mapping software names to their details,\n                                                or None if the \"Installed software\" table is not found.\n        \"\"\"\n        if \"Installed software\" in tables:\n            software = tables[\"Installed software\"]\n            software_map, _dup = LOD.getLookup(\n                software, \"Product\", withDuplicates=False\n            )\n            return software_map\n        return None\n\n    def check_version(self) -&gt; str:\n        \"\"\"\n        Check the MediaWiki version of the site.\n\n        Returns:\n            str: The MediaWiki version string, or an error message if the check fails.\n        \"\"\"\n        client = self.wiki_client\n        site_info = client.get_site_info()\n        generator = site_info.get(\"generator\")\n        version = generator.replace(\"MediaWiki \", \"\")\n        return version\n\n    def check_version_via_url(self) -&gt; str:\n        \"\"\"\n        Check the MediaWiki version of the site.\n\n        Returns:\n            str: The MediaWiki version string, or an error message if the check fails.\n        \"\"\"\n        url = self.wiki_url\n        if not \"index.php\" in self.wiki_url:\n            url = f\"{url}/index.php\"\n        version_url = f\"{self.wiki_url}?title=Special:Version\"\n        mw_version = \"?\"\n        try:\n            html_tables = HtmlTables(\n                version_url, debug=self.debug, showHtml=self.show_html\n            )\n            tables = html_tables.get_tables(\"h2\")\n            software_map = self.get_software_version_map(tables)\n            if software_map and \"MediaWiki\" in software_map:\n                mw_version = software_map[\"MediaWiki\"][\"Version\"]\n        except Exception as ex:\n            mw_version = f\"error: {str(ex)}\"\n        return mw_version\n</code></pre>"},{"location":"#frontend.mediawiki_site.MediaWikiSite.__init__","title":"<code>__init__(wiki_user, row_index=0, debug=False, show_html=False)</code>","text":"<p>constructor</p> Source code in <code>frontend/mediawiki_site.py</code> <pre><code>def __init__(\n    self,\n    wiki_user: WikiUser,\n    row_index: int = 0,\n    debug: bool = False,\n    show_html: bool = False,\n):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.row_no = row_index + 1\n    self.wiki_user = wiki_user\n    self.wiki_url = self.wiki_user.url\n    self.debug = debug\n    self.show_html = show_html\n    self.wiki_backup = WikiBackup(wiki_user)\n    self._wiki_client = None\n    self.task_runner = TaskRunner()\n</code></pre>"},{"location":"#frontend.mediawiki_site.MediaWikiSite.check_version","title":"<code>check_version()</code>","text":"<p>Check the MediaWiki version of the site.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The MediaWiki version string, or an error message if the check fails.</p> Source code in <code>frontend/mediawiki_site.py</code> <pre><code>def check_version(self) -&gt; str:\n    \"\"\"\n    Check the MediaWiki version of the site.\n\n    Returns:\n        str: The MediaWiki version string, or an error message if the check fails.\n    \"\"\"\n    client = self.wiki_client\n    site_info = client.get_site_info()\n    generator = site_info.get(\"generator\")\n    version = generator.replace(\"MediaWiki \", \"\")\n    return version\n</code></pre>"},{"location":"#frontend.mediawiki_site.MediaWikiSite.check_version_via_url","title":"<code>check_version_via_url()</code>","text":"<p>Check the MediaWiki version of the site.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The MediaWiki version string, or an error message if the check fails.</p> Source code in <code>frontend/mediawiki_site.py</code> <pre><code>def check_version_via_url(self) -&gt; str:\n    \"\"\"\n    Check the MediaWiki version of the site.\n\n    Returns:\n        str: The MediaWiki version string, or an error message if the check fails.\n    \"\"\"\n    url = self.wiki_url\n    if not \"index.php\" in self.wiki_url:\n        url = f\"{url}/index.php\"\n    version_url = f\"{self.wiki_url}?title=Special:Version\"\n    mw_version = \"?\"\n    try:\n        html_tables = HtmlTables(\n            version_url, debug=self.debug, showHtml=self.show_html\n        )\n        tables = html_tables.get_tables(\"h2\")\n        software_map = self.get_software_version_map(tables)\n        if software_map and \"MediaWiki\" in software_map:\n            mw_version = software_map[\"MediaWiki\"][\"Version\"]\n    except Exception as ex:\n        mw_version = f\"error: {str(ex)}\"\n    return mw_version\n</code></pre>"},{"location":"#frontend.mediawiki_site.MediaWikiSite.get_software_version_map","title":"<code>get_software_version_map(tables)</code>","text":"<p>Extract software map from the Special:Version tables.</p> <p>Parameters:</p> Name Type Description Default <code>tables</code> <code>Dict[str, List[Dict[str, Any]]]</code> <p>Dictionary of tables with their headers as keys.</p> required <p>Returns:</p> Type Description <code>Optional[Dict[str, Dict[str, Any]]]</code> <p>Optional[Dict[str, Dict[str, Any]]]: A dictionary mapping software names to their details,                                 or None if the \"Installed software\" table is not found.</p> Source code in <code>frontend/mediawiki_site.py</code> <pre><code>def get_software_version_map(\n    self, tables: Dict[str, List[Dict[str, Any]]]\n) -&gt; Optional[Dict[str, Dict[str, Any]]]:\n    \"\"\"\n    Extract software map from the Special:Version tables.\n\n    Args:\n        tables (Dict[str, List[Dict[str, Any]]]): Dictionary of tables with their headers as keys.\n\n    Returns:\n        Optional[Dict[str, Dict[str, Any]]]: A dictionary mapping software names to their details,\n                                            or None if the \"Installed software\" table is not found.\n    \"\"\"\n    if \"Installed software\" in tables:\n        software = tables[\"Installed software\"]\n        software_map, _dup = LOD.getLookup(\n            software, \"Product\", withDuplicates=False\n        )\n        return software_map\n    return None\n</code></pre>"},{"location":"#frontend.servers_view","title":"<code>servers_view</code>","text":"<p>Created on 2025-07-23</p> <p>@author: wf</p>"},{"location":"#frontend.servers_view.ServerView","title":"<code>ServerView</code>","text":"<p>               Bases: <code>NodeView</code></p> <p>A class responsible for displaying details of a  Server</p> Source code in <code>frontend/servers_view.py</code> <pre><code>class ServerView(NodeView):\n    \"\"\"\n    A class responsible for displaying details of a  Server\n    \"\"\"\n\n    def setup_ui(self):\n        \"\"\"Setup UI with code display.\"\"\"\n        try:\n            if self.node_data:\n                self.server = self.node_data.get(\"_instance\")\n                html_markup = self.server.as_html()\n                self.html = ui.html(html_markup)\n                pass\n                # Add probe button\n                ui.button(\"Probe Remote\", on_click=self.probe)\n            super().setup_ui()\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n\n    async def probe(self):\n        \"\"\"Probe remote server and update display.\"\"\"\n        try:\n            self.server.probe_remote()\n            html_markup = self.server.as_html()\n            self.html.content = html_markup\n        except Exception as ex:\n            self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.servers_view.ServerView.probe","title":"<code>probe()</code>  <code>async</code>","text":"<p>Probe remote server and update display.</p> Source code in <code>frontend/servers_view.py</code> <pre><code>async def probe(self):\n    \"\"\"Probe remote server and update display.\"\"\"\n    try:\n        self.server.probe_remote()\n        html_markup = self.server.as_html()\n        self.html.content = html_markup\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.servers_view.ServerView.setup_ui","title":"<code>setup_ui()</code>","text":"<p>Setup UI with code display.</p> Source code in <code>frontend/servers_view.py</code> <pre><code>def setup_ui(self):\n    \"\"\"Setup UI with code display.\"\"\"\n    try:\n        if self.node_data:\n            self.server = self.node_data.get(\"_instance\")\n            html_markup = self.server.as_html()\n            self.html = ui.html(html_markup)\n            pass\n            # Add probe button\n            ui.button(\"Probe Remote\", on_click=self.probe)\n        super().setup_ui()\n    except Exception as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.servers_view.ServersView","title":"<code>ServersView</code>","text":"<p>Display servers</p> Source code in <code>frontend/servers_view.py</code> <pre><code>class ServersView:\n    \"\"\"\n    Display servers\n    \"\"\"\n\n    def __init__(self, solution, servers: Servers):\n        self.solution = solution\n        self.servers = servers\n\n    @classmethod\n    def add_to_graph(cls, servers, graph: MogwaiGraph, with_progress: bool):\n        \"\"\"\n        add my serves to the graph\n        \"\"\"\n        items = servers.servers.items()\n        iterator = (\n            tqdm(items, desc=\"Adding servers to graph\") if with_progress else items\n        )\n        for name, server in iterator:\n            props = {\n                \"hostname\": server.hostname,\n                \"platform\": server.platform,\n                \"_instance\": server,\n            }\n            _node = graph.add_labeled_node(\"Server\", name=name, properties=props)\n        return graph\n</code></pre>"},{"location":"#frontend.servers_view.ServersView.add_to_graph","title":"<code>add_to_graph(servers, graph, with_progress)</code>  <code>classmethod</code>","text":"<p>add my serves to the graph</p> Source code in <code>frontend/servers_view.py</code> <pre><code>@classmethod\ndef add_to_graph(cls, servers, graph: MogwaiGraph, with_progress: bool):\n    \"\"\"\n    add my serves to the graph\n    \"\"\"\n    items = servers.servers.items()\n    iterator = (\n        tqdm(items, desc=\"Adding servers to graph\") if with_progress else items\n    )\n    for name, server in iterator:\n        props = {\n            \"hostname\": server.hostname,\n            \"platform\": server.platform,\n            \"_instance\": server,\n        }\n        _node = graph.add_labeled_node(\"Server\", name=name, properties=props)\n    return graph\n</code></pre>"},{"location":"#frontend.version","title":"<code>version</code>","text":"<p>Created on 2022-12-03</p> <p>@author: wf</p>"},{"location":"#frontend.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyWikiCMS</p> Source code in <code>frontend/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for pyWikiCMS\n    \"\"\"\n\n    name = \"pyWikiCMS\"\n    description = \"pyWikiCMS: python implementation of a Mediawiki based Content Management System\"\n    version = frontend.__version__\n    date = \"2022-11-16\"\n    updated = \"2025-06-16\"\n    authors = \"Wolfgang Fahl\"\n    doc_url = \"http://wiki.bitplan.com/index.php/PyWikiCMS\"\n    chat_url = \"https://github.com/BITPlan/pyWikiCMS/discussions\"\n    cm_url = \"https://github.com/BITPlan/pyWikiCMS\"\n    license = f\"\"\"Copyright 2022-2025 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#frontend.webscrape","title":"<code>webscrape</code>","text":"<p>Created on 2020-08-20</p> <p>@author: wf</p>"},{"location":"#frontend.webscrape.WebScrape","title":"<code>WebScrape</code>","text":"<p>               Bases: <code>object</code></p> <p>WebScraper</p> Source code in <code>frontend/webscrape.py</code> <pre><code>class WebScrape(object):\n    \"\"\"\n    WebScraper\n    \"\"\"\n\n    def __init__(self, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.err = None\n        self.valid = False\n        self.debug = debug\n        self.showHtml = showHtml\n\n    def getSoup(self, url, showHtml: bool):\n        \"\"\"\n        get the beautiful Soup parser\n\n        Args:\n           showHtml(bool): True if the html code should be pretty printed and shown\n        \"\"\"\n        req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n        html = urlopen(req).read()\n        soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n        if showHtml:\n            self.printPrettyHtml(soup)\n\n        return soup\n\n    def printPrettyHtml(self, soup):\n        \"\"\"\n        print the prettified html for the given soup\n\n        Args:\n            soup(BeuatifulSoup): the parsed html to print\n        \"\"\"\n        prettyHtml = soup.prettify()\n        print(prettyHtml)\n</code></pre>"},{"location":"#frontend.webscrape.WebScrape.__init__","title":"<code>__init__(debug=False, showHtml=False)</code>","text":"<p>Constructor</p> Source code in <code>frontend/webscrape.py</code> <pre><code>def __init__(self, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.err = None\n    self.valid = False\n    self.debug = debug\n    self.showHtml = showHtml\n</code></pre>"},{"location":"#frontend.webscrape.WebScrape.getSoup","title":"<code>getSoup(url, showHtml)</code>","text":"<p>get the beautiful Soup parser</p> <p>Parameters:</p> Name Type Description Default <code>showHtml(bool)</code> <p>True if the html code should be pretty printed and shown</p> required Source code in <code>frontend/webscrape.py</code> <pre><code>def getSoup(self, url, showHtml: bool):\n    \"\"\"\n    get the beautiful Soup parser\n\n    Args:\n       showHtml(bool): True if the html code should be pretty printed and shown\n    \"\"\"\n    req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n    html = urlopen(req).read()\n    soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n    if showHtml:\n        self.printPrettyHtml(soup)\n\n    return soup\n</code></pre>"},{"location":"#frontend.webscrape.WebScrape.printPrettyHtml","title":"<code>printPrettyHtml(soup)</code>","text":"<p>print the prettified html for the given soup</p> <p>Parameters:</p> Name Type Description Default <code>soup(BeuatifulSoup)</code> <p>the parsed html to print</p> required Source code in <code>frontend/webscrape.py</code> <pre><code>def printPrettyHtml(self, soup):\n    \"\"\"\n    print the prettified html for the given soup\n\n    Args:\n        soup(BeuatifulSoup): the parsed html to print\n    \"\"\"\n    prettyHtml = soup.prettify()\n    print(prettyHtml)\n</code></pre>"},{"location":"#frontend.webserver","title":"<code>webserver</code>","text":"<p>Created on 2020-12-30</p> <p>@author: wf</p>"},{"location":"#frontend.webserver.CmsSolution","title":"<code>CmsSolution</code>","text":"<p>               Bases: <code>GraphNavigatorSolution</code></p> <p>Content management solution</p> Source code in <code>frontend/webserver.py</code> <pre><code>class CmsSolution(GraphNavigatorSolution):\n    \"\"\"\n    Content management solution\n    \"\"\"\n\n    def __init__(self, webserver: CmsWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (Cms    WebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.wiki_grid = WikiGrid(self)\n        self.servers = webserver.servers\n        self.server = webserver.server\n        self.hostname = webserver.hostname\n        self.servers_view = ServersView(self, self.servers)\n\n    def configure_menu(self):\n        \"\"\"\n        configure my menu\n        \"\"\"\n        InputWebSolution.configure_menu(self)\n        self.login = self.webserver.login\n        self.sso_solution = SsoSolution(webserver=self.webserver)\n        self.sso_solution.configure_menu()\n        # icons from https://fonts.google.com/icons\n        if self.webserver.authenticated():\n            self.link_button(name=\"wikis\", icon_name=\"menu_book\", target=\"/wikis\")\n            self.link_button(name=\"servers\", icon_name=\"cloud\", target=\"/servers\")\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n        \"\"\"\n\n        def show():\n            with self.content_div:\n                ui.label(f\"Welcome to {self.hostname}\")\n                if self.server:\n                    html_markup = self.server.as_html()\n                    ui.html(html_markup)\n                pass\n\n        await self.setup_content_div(show)\n\n    async def show_wikis(self):\n        def show():\n            with self.content_div:\n                self.wiki_grid.setup()\n\n        await self.setup_content_div(show)\n\n    async def show_nodes(self, node_type: str):\n        \"\"\"\n        show nodes of the given type\n\n        Args:\n            node_type(str): the type of nodes to show\n        \"\"\"\n\n        def show():\n            try:\n                config = NodeViewConfig(\n                    solution=self,\n                    graph=self.graph,\n                    schema=self.schema,\n                    node_type=node_type,\n                )\n                if not config.node_type_config:\n                    ui.label(f\"invalid_node_type: {node_type}\")\n                    return\n                node_table_view = NodeTableView(config=config)\n                node_table_view.setup_ui()\n            except Exception as ex:\n                self.handle_exception(ex)\n\n        await self.setup_content_div(show)\n\n    async def show_servers(self):\n        await self.show_nodes(\"Server\")\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (Cms    WebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>frontend/webserver.py</code> <pre><code>def __init__(self, webserver: CmsWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (Cms    WebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.wiki_grid = WikiGrid(self)\n    self.servers = webserver.servers\n    self.server = webserver.server\n    self.hostname = webserver.hostname\n    self.servers_view = ServersView(self, self.servers)\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.configure_menu","title":"<code>configure_menu()</code>","text":"<p>configure my menu</p> Source code in <code>frontend/webserver.py</code> <pre><code>def configure_menu(self):\n    \"\"\"\n    configure my menu\n    \"\"\"\n    InputWebSolution.configure_menu(self)\n    self.login = self.webserver.login\n    self.sso_solution = SsoSolution(webserver=self.webserver)\n    self.sso_solution.configure_menu()\n    # icons from https://fonts.google.com/icons\n    if self.webserver.authenticated():\n        self.link_button(name=\"wikis\", icon_name=\"menu_book\", target=\"/wikis\")\n        self.link_button(name=\"servers\", icon_name=\"cloud\", target=\"/servers\")\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>frontend/webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n    \"\"\"\n\n    def show():\n        with self.content_div:\n            ui.label(f\"Welcome to {self.hostname}\")\n            if self.server:\n                html_markup = self.server.as_html()\n                ui.html(html_markup)\n            pass\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.show_nodes","title":"<code>show_nodes(node_type)</code>  <code>async</code>","text":"<p>show nodes of the given type</p> <p>Parameters:</p> Name Type Description Default <code>node_type(str)</code> <p>the type of nodes to show</p> required Source code in <code>frontend/webserver.py</code> <pre><code>async def show_nodes(self, node_type: str):\n    \"\"\"\n    show nodes of the given type\n\n    Args:\n        node_type(str): the type of nodes to show\n    \"\"\"\n\n    def show():\n        try:\n            config = NodeViewConfig(\n                solution=self,\n                graph=self.graph,\n                schema=self.schema,\n                node_type=node_type,\n            )\n            if not config.node_type_config:\n                ui.label(f\"invalid_node_type: {node_type}\")\n                return\n            node_table_view = NodeTableView(config=config)\n            node_table_view.setup_ui()\n        except Exception as ex:\n            self.handle_exception(ex)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer","title":"<code>CmsWebServer</code>","text":"<p>               Bases: <code>GraphNavigatorWebserver</code></p> <p>WebServer class that manages the servers</p> Source code in <code>frontend/webserver.py</code> <pre><code>class CmsWebServer(GraphNavigatorWebserver):\n    \"\"\"\n    WebServer class that manages the servers\n\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2023-2025 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=8252,\n            timeout=10.0,\n            short_name=\"wikicms\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = CmsSolution\n        return server_config\n\n    def authenticated(self) -&gt; bool:\n        \"\"\"\n        check authentication\n        \"\"\"\n        allow = self.login.authenticated()\n        if self.server:\n            allow = allow or self.server.auto_login\n        return allow\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        GraphNavigatorWebserver.__init__(self, config=CmsWebServer.get_config())\n        self.servers = Servers.of_config_path()\n        self.wiki_frontends = WikiFrontends(self.servers)\n        self.users = Sso_Users(self.config.short_name)\n        self.login = Login(self, self.users)\n        self.hostname = socket.gethostname()\n        self.server = self.servers.servers.get(self.hostname)\n        if self.server:\n            self.server.probe_local()\n\n        @ui.page(\"/servers\")\n        async def show_servers(client: Client):\n            if not self.authenticated():\n                return RedirectResponse(\"/login\")\n            return await self.page(client, CmsSolution.show_servers)\n\n        @ui.page(\"/wikis\")\n        async def show_wikis(client: Client):\n            if not self.authenticated():\n                return RedirectResponse(\"/login\")\n            return await self.page(client, CmsSolution.show_wikis)\n\n        @ui.page(\"/login\")\n        async def login(client: Client) -&gt; None:\n            return await self.page(client, CmsSolution.show_login)\n\n        @app.get(\"/{frontend_name}/{page_path:path}\")\n        def render_path(frontend_name: str, page_path: str) -&gt; HTMLResponse:\n            \"\"\"\n            Handles a GET request to render the path of the given frontend.\n\n            Args:\n                frontend_name: The name of the frontend to be rendered.\n                page_path: The specific path within the frontend to be rendered.\n\n            Returns:\n                An HTMLResponse containing the rendered page content.\n\n            \"\"\"\n            return self.render_path(frontend_name, page_path)\n\n    def render_path(self, frontend_name: str, page_path: str):\n        \"\"\"\n        Renders the content for a specific path of the given frontend.\n\n        Args:\n            frontend_name: The name of the frontend to be rendered.\n            page_path: The specific path within the frontend to be rendered.\n\n        Returns:\n            An HTMLResponse containing the rendered page content or an error page if something goes wrong.\n\n        Raises:\n            SomeException: If an error occurs during page content retrieval or rendering.\n\n        \"\"\"\n        wiki_frontend = self.wiki_frontends.wiki_frontends.get(frontend_name, None)\n        if wiki_frontend is None:\n            raise HTTPException(\n                status_code=404, detail=f\"frontend {frontend_name} is not available\"\n            )\n        response = wiki_frontend.get_path_response(f\"/{page_path}\")\n        return response\n\n    def configure_run(self):\n        \"\"\"\n        configure command line specific details\n        \"\"\"\n        super().configure_run()\n        self.wiki_frontends.enableSites(self.args.sites)\n        module_path = os.path.dirname(os.path.abspath(__file__))\n        yaml_path = os.path.join(module_path, \"resources\", \"schema.yaml\")\n        self.load_schema(yaml_path)\n        ServersView.add_to_graph(self.servers, self.graph, with_progress=True)\n        pass\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>frontend/webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    GraphNavigatorWebserver.__init__(self, config=CmsWebServer.get_config())\n    self.servers = Servers.of_config_path()\n    self.wiki_frontends = WikiFrontends(self.servers)\n    self.users = Sso_Users(self.config.short_name)\n    self.login = Login(self, self.users)\n    self.hostname = socket.gethostname()\n    self.server = self.servers.servers.get(self.hostname)\n    if self.server:\n        self.server.probe_local()\n\n    @ui.page(\"/servers\")\n    async def show_servers(client: Client):\n        if not self.authenticated():\n            return RedirectResponse(\"/login\")\n        return await self.page(client, CmsSolution.show_servers)\n\n    @ui.page(\"/wikis\")\n    async def show_wikis(client: Client):\n        if not self.authenticated():\n            return RedirectResponse(\"/login\")\n        return await self.page(client, CmsSolution.show_wikis)\n\n    @ui.page(\"/login\")\n    async def login(client: Client) -&gt; None:\n        return await self.page(client, CmsSolution.show_login)\n\n    @app.get(\"/{frontend_name}/{page_path:path}\")\n    def render_path(frontend_name: str, page_path: str) -&gt; HTMLResponse:\n        \"\"\"\n        Handles a GET request to render the path of the given frontend.\n\n        Args:\n            frontend_name: The name of the frontend to be rendered.\n            page_path: The specific path within the frontend to be rendered.\n\n        Returns:\n            An HTMLResponse containing the rendered page content.\n\n        \"\"\"\n        return self.render_path(frontend_name, page_path)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.authenticated","title":"<code>authenticated()</code>","text":"<p>check authentication</p> Source code in <code>frontend/webserver.py</code> <pre><code>def authenticated(self) -&gt; bool:\n    \"\"\"\n    check authentication\n    \"\"\"\n    allow = self.login.authenticated()\n    if self.server:\n        allow = allow or self.server.auto_login\n    return allow\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.configure_run","title":"<code>configure_run()</code>","text":"<p>configure command line specific details</p> Source code in <code>frontend/webserver.py</code> <pre><code>def configure_run(self):\n    \"\"\"\n    configure command line specific details\n    \"\"\"\n    super().configure_run()\n    self.wiki_frontends.enableSites(self.args.sites)\n    module_path = os.path.dirname(os.path.abspath(__file__))\n    yaml_path = os.path.join(module_path, \"resources\", \"schema.yaml\")\n    self.load_schema(yaml_path)\n    ServersView.add_to_graph(self.servers, self.graph, with_progress=True)\n    pass\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.render_path","title":"<code>render_path(frontend_name, page_path)</code>","text":"<p>Renders the content for a specific path of the given frontend.</p> <p>Parameters:</p> Name Type Description Default <code>frontend_name</code> <code>str</code> <p>The name of the frontend to be rendered.</p> required <code>page_path</code> <code>str</code> <p>The specific path within the frontend to be rendered.</p> required <p>Returns:</p> Type Description <p>An HTMLResponse containing the rendered page content or an error page if something goes wrong.</p> <p>Raises:</p> Type Description <code>SomeException</code> <p>If an error occurs during page content retrieval or rendering.</p> Source code in <code>frontend/webserver.py</code> <pre><code>def render_path(self, frontend_name: str, page_path: str):\n    \"\"\"\n    Renders the content for a specific path of the given frontend.\n\n    Args:\n        frontend_name: The name of the frontend to be rendered.\n        page_path: The specific path within the frontend to be rendered.\n\n    Returns:\n        An HTMLResponse containing the rendered page content or an error page if something goes wrong.\n\n    Raises:\n        SomeException: If an error occurs during page content retrieval or rendering.\n\n    \"\"\"\n    wiki_frontend = self.wiki_frontends.wiki_frontends.get(frontend_name, None)\n    if wiki_frontend is None:\n        raise HTTPException(\n            status_code=404, detail=f\"frontend {frontend_name} is not available\"\n        )\n    response = wiki_frontend.get_path_response(f\"/{page_path}\")\n    return response\n</code></pre>"},{"location":"#frontend.wikicms","title":"<code>wikicms</code>","text":"<p>Created on 2020-07-27</p> <p>@author: wf</p>"},{"location":"#frontend.wikicms.WikiFrontend","title":"<code>WikiFrontend</code>","text":"<p>               Bases: <code>object</code></p> <p>Wiki Content Management System Frontend</p> Source code in <code>frontend/wikicms.py</code> <pre><code>class WikiFrontend(object):\n    \"\"\"\n    Wiki Content Management System Frontend\n    \"\"\"\n\n    with_login: bool = True\n\n    def __init__(\n        self,\n        frontend: FrontendSite,\n        parser: str = \"lxml\",\n        proxy_prefixes=[\"/images/\", \"/videos\"],\n        debug: bool = False,\n        filterKeys=None,\n    ):\n        \"\"\"\n        Constructor\n        Args:\n            frontend(FrontendSite): the frontend\n            parser(str): the beautiful soup parser to use e.g. html.parser\n            proxy_prefixes(list): the list of prefixes that need direct proxy access\n            debug: (bool): True if debugging should be on\n            filterKeys: (list): a list of keys for filters to be applied e.g. editsection\n        \"\"\"\n        self.logger = logging.getLogger(self.__class__.__name__)\n        self.parser = parser\n        self.proxy_prefixes = proxy_prefixes\n        self.frontend = frontend\n        self.name = self.frontend.name\n        self.debug = debug\n        self.wiki = None\n        if filterKeys is None:\n            self.filterKeys = [\"editsection\", \"parser-output\", \"parser-output\"]\n        else:\n            self.filterKeys = []\n\n    def log(self, msg: str):\n        \"\"\"\n        log the given message if debugging is true\n\n        Args:\n            msg (str): the message to log\n        \"\"\"\n        if self.debug:\n            print(msg, flush=True)\n\n    @staticmethod\n    def extract_site_and_path(path: str):\n        \"\"\"\n        Splits the given path into the site component and the remaining path.\n\n        This static method assumes that the 'site' is the first element of the\n        path when split by \"/\", and the 'path' is the rest of the string after\n        the site.\n\n        Parameters:\n        path (str): The complete path to split.\n\n        Returns:\n        tuple: A tuple where the first element is the site and the second\n               element is the subsequent path.\n        \"\"\"\n        # Check if the path is empty or does not contain a \"/\"\n        if not path or \"/\" not in path:\n            return \"\", path\n\n        # Split the path into parts using the \"/\" as a separator\n        parts = path.split(\"/\")\n\n        # The first part is the site, the rest is joined back into a path\n        site = parts[0]\n        remaining_path = \"/\" + \"/\".join(parts[1:])\n\n        return site, remaining_path\n\n    def open(self):\n        \"\"\"\n        open the frontend\n\n        \"\"\"\n        if self.wiki is None:\n            self.wiki = WikiClient.ofWikiId(self.frontend.wikiId)\n            if WikiFrontend.with_login:\n                self.wiki.login()\n            self.smwclient = SMWClient(self.wiki.getSite())\n            self.cms_pages = self.get_cms_pages()\n            self.frontend.enabled = True\n\n    def get_cms_pages(self) -&gt; dict:\n        \"\"\"\n        get the Content Management elements for this site\n        \"\"\"\n        cms_pages = {}\n        ask_query = \"[[Category:CMS]]\"\n        page_records = self.smwclient.query(ask_query, \"cms pages\")\n        for page_title in list(page_records):\n            page_title, html, error = self.getContent(page_title)\n            if not error:\n                cms_pages[page_title] = html\n            else:\n                self.logger.warn(error)\n        return cms_pages\n\n    def errMsg(self, ex):\n        if self.debug:\n            msg = \"%s\\n%s\" % (repr(ex), traceback.format_exc())\n        else:\n            msg = repr(ex)\n        return msg\n\n    def wikiPage(self, pagePath: str) -&gt; str:\n        \"\"\"\n        Get the wiki page for the given page path.\n\n        Args:\n            pagePath (str): The path of the page.\n\n        Returns:\n            str: The title of the page.\n        \"\"\"\n        if \"/index.php/\" in pagePath:\n            wikipage = pagePath.replace(\"/index.php/\", \"\")\n        elif pagePath.startswith(\"/\"):\n            wikipage = pagePath[1:]\n        else:\n            wikipage = pagePath\n        return wikipage\n\n    def checkPath(self, pagePath: str) -&gt; str:\n        \"\"\"\n        check the given pathPath\n\n        Args:\n            pagePath (str): the page Path to check\n\n        Returns:\n            str: None or an error message with the illegal chars being used\n        \"\"\"\n        error = None\n        self.log(pagePath)\n        illegalChars = [\"{\", \"}\", \"&lt;\", \"&gt;\", \"[\", \"]\", \"|\"]\n        for illegalChar in illegalChars:\n            if illegalChar in pagePath:\n                error = \"invalid char %s in given pagePath \" % (illegalChar)\n        return error\n\n    def needsProxy(self, path: str) -&gt; bool:\n        \"\"\"\n        Args:\n            path (str): the path to check\n\n        Returns:\n            bool: True if this path needs to be proxied\n        \"\"\"\n        needs_proxy = False\n        for prefix in self.proxy_prefixes:\n            needs_proxy = needs_proxy or path.startswith(prefix)\n        return needs_proxy\n\n    def proxy(self, path: str) -&gt; str:\n        \"\"\"\n        Proxy a request.\n        See https://stackoverflow.com/a/50231825/1497139\n\n        Args:\n            path (str): the path to proxy\n\n        Returns:\n            the proxied result as a string\n        \"\"\"\n        wikiUser = self.wiki.wikiUser\n        url = f\"{wikiUser.url}{wikiUser.scriptPath}{path}\"\n\n        # Get the response\n        response = requests.get(url)\n\n        return response\n\n    def filter(self, html: str) -&gt; str:\n        \"\"\"\n        filter the given html\n        \"\"\"\n        return self.doFilter(html, self.filterKeys)\n\n    def fixNode(self, node, attribute, prefix, delim=None):\n        \"\"\"\n        fix the given node\n\n        node (BeautifulSoup): the node\n        attribute (str): the name of the attribute e.g. \"href\", \"src\"\n        prefix (str): the prefix to replace e.g. \"/\", \"/images\", \"/thumbs\"\n        delim (str): if not None the delimiter for multiple values\n        \"\"\"\n        siteprefix = f\"/{self.frontend.name}{prefix}\"\n        if attribute in node.attrs:\n            attrval = node.attrs[attribute]\n            if delim is not None:\n                vals = attrval.split(delim)\n            else:\n                vals = [attrval]\n                delim = \"\"\n            newvals = []\n            for val in vals:\n                if val.startswith(prefix):\n                    newvals.append(val.replace(prefix, siteprefix, 1))\n                else:\n                    newvals.append(val)\n            if delim is not None:\n                node.attrs[attribute] = delim.join(newvals)\n\n    def fix_images_and_videos(self, soup):\n        \"\"\"\n        fix image and video entries in the source code\n        \"\"\"\n        for img in soup.findAll(\"img\"):\n            self.fixNode(img, \"src\", \"/\")\n            self.fixNode(img, \"srcset\", \"/\", \", \")\n        for video in soup.findAll(\"video\"):\n            for source in video.findAll(\"source\"):\n                self.fixNode(source, \"src\", \"/\")\n\n    def fixHtml(self, soup):\n        \"\"\"\n        fix the HTML in the given soup\n\n        Args:\n            soup(BeautifulSoup): the html parser\n        \"\"\"\n        self.fix_images_and_videos(soup)\n        # fix absolute hrefs\n        for a in soup.findAll(\"a\"):\n            self.fixNode(a, \"href\", \"/\")\n        return soup\n\n    def unwrap(self, soup) -&gt; str:\n        \"\"\"\n        unwrap the soup\n        \"\"\"\n        html = str(soup)\n        html = html.replace(\"&lt;html&gt;&lt;body&gt;\", \"\")\n        html = html.replace(\"&lt;/body&gt;&lt;/html&gt;\", \"\")\n        # Remove  empty paragraphs\n        html = re.sub(r'&lt;p class=\"mw-empty-elt\"&gt;\\s*&lt;/p&gt;', \"\", html)\n\n        # Replace multiple newline characters with a single newline character\n        html = re.sub(r\"\\n\\s*\\n\", \"\\n\", html)\n        return html\n\n    def doFilter(self, html, filterKeys):\n        # https://stackoverflow.com/questions/5598524/can-i-remove-script-tags-with-beautifulsoup\n        soup = BeautifulSoup(html, self.parser)\n        if \"parser-output\" in filterKeys:\n            parserdiv = soup.find(\"div\", {\"class\": \"mw-parser-output\"})\n            if parserdiv:\n                soup = parserdiv\n                inner_html = parserdiv.decode_contents()\n                # Parse the inner HTML string to create a new BeautifulSoup object\n                soup = BeautifulSoup(inner_html, self.parser)\n                pass\n        # https://stackoverflow.com/questions/5041008/how-to-find-elements-by-class\n        if \"editsection\" in filterKeys:\n            for s in soup.select(\"span.mw-editsection\"):\n                s.extract()\n        for comments in soup.findAll(text=lambda text: isinstance(text, Comment)):\n            comments.extract()\n        return soup\n\n    def getContent(self, pagePath: str):\n        \"\"\"get the content for the given pagePath\n        Args:\n            pagePath(str): the pagePath\n            whatToFilter(list): list of filter keys\n        Returns:\n            str: the HTML content for the given path\n        \"\"\"\n        content = None\n        error = None\n        pageTitle = \"?\"\n        try:\n            if pagePath == \"/\":\n                pageTitle = self.frontend.defaultPage\n            else:\n                error = self.checkPath(pagePath)\n                pageTitle = self.wikiPage(pagePath)\n            if error is None:\n                if self.wiki is None:\n                    raise Exception(\n                        \"getContent without wiki - you might want to call open first\"\n                    )\n                content = self.wiki.getHtml(pageTitle)\n                soup = self.filter(content)\n                soup = self.fixHtml(soup)\n                content = self.unwrap(soup)\n        except Exception as e:\n            error = self.errMsg(e)\n        return pageTitle, content, error\n\n    def wrapWithReveal(self, html: str):\n        \"\"\"\n        wrap html content with reveal.js structure and dependencies\n        \"\"\"\n        wrapped_html = f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/white.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"reveal\"&gt;\n        &lt;div class=\"slides\"&gt;\n{html}\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;Reveal.initialize({{\n    }});&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n        return wrapped_html\n\n    def toReveal(self, html: str):\n        \"\"\"\n        convert the given html to reveal\n        see https://revealjs.com/\n        \"\"\"\n        soup = BeautifulSoup(html, \"lxml\")\n        for h2 in soup.findChildren(recursive=True):\n            if h2.name == \"h2\":\n                span = h2.next_element\n                if span.name == \"span\":\n                    tagid = span.get(\"id\")\n                    if tagid.startswith(\"\u2318\u2318\"):\n                        section = soup.new_tag(\"section\")\n                        h2.parent.append(section)\n                        section.insert(0, h2)\n                        tag = h2.next_element\n                        while tag is not None and tag.name != \"h2\":\n                            if tag.parent != h2:\n                                section.append(tag)\n                            tag = tag.next_element\n        html = self.unwrap(soup)\n        return html\n\n    def get_frame(self, page_title: str) -&gt; str:\n        \"\"\"\n        get the frame property for the given page_title\n        \"\"\"\n        frame = None\n        markup = self.wiki.get_wiki_markup(page_title)\n        # {{#set:frame=reveal}}\n        # {{UseFrame|Contact.rythm|\n        patterns = [\n            r\"{{#set:frame=([^}]+)}}\",  # {{#set:frame=reveal}}\n            r\"{{UseFrame\\|([^.]+)\",  # {{UseFrame|Contact.rythm|\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, markup)\n            if match:\n                frame = match.group(1)\n        return frame\n\n    def get_path_response(self, path: str) -&gt; str:\n        \"\"\"\n        get the repsonse for the the given path\n\n        Args:\n            path(str): the path to render the content for\n\n        Returns:\n            Response: a FastAPI response\n        \"\"\"\n        if self.needsProxy(path):\n            html_response = self.proxy(path)\n            # Create a FastAPI response object\n            response = Response(\n                content=html_response.content,\n                status_code=html_response.status_code,\n                headers=dict(html_response.headers),\n            )\n        else:\n            page_title, content, error = self.getContent(path)\n            html_frame = HtmlFrame(self, title=page_title)\n            html = content\n            framed_html = None\n            if error:\n                html = f\"error getting {page_title} for {self.name}:&lt;br&gt;{error}\"\n            else:\n                if \"&lt;slideshow\" in html or \"&amp;lt;slideshow\" in html:\n                    content = self.toReveal(content)\n                    # Complete reveal.js webpage\n                    framed_html = self.wrapWithReveal(html)\n                    html = content\n\n            if not framed_html:\n                framed_html = html_frame.frame(html)\n            response = HTMLResponse(framed_html)\n        return response\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.__init__","title":"<code>__init__(frontend, parser='lxml', proxy_prefixes=['/images/', '/videos'], debug=False, filterKeys=None)</code>","text":"<p>Constructor Args:     frontend(FrontendSite): the frontend     parser(str): the beautiful soup parser to use e.g. html.parser     proxy_prefixes(list): the list of prefixes that need direct proxy access     debug: (bool): True if debugging should be on     filterKeys: (list): a list of keys for filters to be applied e.g. editsection</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def __init__(\n    self,\n    frontend: FrontendSite,\n    parser: str = \"lxml\",\n    proxy_prefixes=[\"/images/\", \"/videos\"],\n    debug: bool = False,\n    filterKeys=None,\n):\n    \"\"\"\n    Constructor\n    Args:\n        frontend(FrontendSite): the frontend\n        parser(str): the beautiful soup parser to use e.g. html.parser\n        proxy_prefixes(list): the list of prefixes that need direct proxy access\n        debug: (bool): True if debugging should be on\n        filterKeys: (list): a list of keys for filters to be applied e.g. editsection\n    \"\"\"\n    self.logger = logging.getLogger(self.__class__.__name__)\n    self.parser = parser\n    self.proxy_prefixes = proxy_prefixes\n    self.frontend = frontend\n    self.name = self.frontend.name\n    self.debug = debug\n    self.wiki = None\n    if filterKeys is None:\n        self.filterKeys = [\"editsection\", \"parser-output\", \"parser-output\"]\n    else:\n        self.filterKeys = []\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.checkPath","title":"<code>checkPath(pagePath)</code>","text":"<p>check the given pathPath</p> <p>Parameters:</p> Name Type Description Default <code>pagePath</code> <code>str</code> <p>the page Path to check</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>None or an error message with the illegal chars being used</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def checkPath(self, pagePath: str) -&gt; str:\n    \"\"\"\n    check the given pathPath\n\n    Args:\n        pagePath (str): the page Path to check\n\n    Returns:\n        str: None or an error message with the illegal chars being used\n    \"\"\"\n    error = None\n    self.log(pagePath)\n    illegalChars = [\"{\", \"}\", \"&lt;\", \"&gt;\", \"[\", \"]\", \"|\"]\n    for illegalChar in illegalChars:\n        if illegalChar in pagePath:\n            error = \"invalid char %s in given pagePath \" % (illegalChar)\n    return error\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.extract_site_and_path","title":"<code>extract_site_and_path(path)</code>  <code>staticmethod</code>","text":"<p>Splits the given path into the site component and the remaining path.</p> <p>This static method assumes that the 'site' is the first element of the path when split by \"/\", and the 'path' is the rest of the string after the site.</p> <p>Parameters: path (str): The complete path to split.</p> <p>tuple: A tuple where the first element is the site and the second        element is the subsequent path.</p> Source code in <code>frontend/wikicms.py</code> <pre><code>@staticmethod\ndef extract_site_and_path(path: str):\n    \"\"\"\n    Splits the given path into the site component and the remaining path.\n\n    This static method assumes that the 'site' is the first element of the\n    path when split by \"/\", and the 'path' is the rest of the string after\n    the site.\n\n    Parameters:\n    path (str): The complete path to split.\n\n    Returns:\n    tuple: A tuple where the first element is the site and the second\n           element is the subsequent path.\n    \"\"\"\n    # Check if the path is empty or does not contain a \"/\"\n    if not path or \"/\" not in path:\n        return \"\", path\n\n    # Split the path into parts using the \"/\" as a separator\n    parts = path.split(\"/\")\n\n    # The first part is the site, the rest is joined back into a path\n    site = parts[0]\n    remaining_path = \"/\" + \"/\".join(parts[1:])\n\n    return site, remaining_path\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.filter","title":"<code>filter(html)</code>","text":"<p>filter the given html</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def filter(self, html: str) -&gt; str:\n    \"\"\"\n    filter the given html\n    \"\"\"\n    return self.doFilter(html, self.filterKeys)\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.fixHtml","title":"<code>fixHtml(soup)</code>","text":"<p>fix the HTML in the given soup</p> <p>Parameters:</p> Name Type Description Default <code>soup(BeautifulSoup)</code> <p>the html parser</p> required Source code in <code>frontend/wikicms.py</code> <pre><code>def fixHtml(self, soup):\n    \"\"\"\n    fix the HTML in the given soup\n\n    Args:\n        soup(BeautifulSoup): the html parser\n    \"\"\"\n    self.fix_images_and_videos(soup)\n    # fix absolute hrefs\n    for a in soup.findAll(\"a\"):\n        self.fixNode(a, \"href\", \"/\")\n    return soup\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.fixNode","title":"<code>fixNode(node, attribute, prefix, delim=None)</code>","text":"<p>fix the given node</p> <p>node (BeautifulSoup): the node attribute (str): the name of the attribute e.g. \"href\", \"src\" prefix (str): the prefix to replace e.g. \"/\", \"/images\", \"/thumbs\" delim (str): if not None the delimiter for multiple values</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def fixNode(self, node, attribute, prefix, delim=None):\n    \"\"\"\n    fix the given node\n\n    node (BeautifulSoup): the node\n    attribute (str): the name of the attribute e.g. \"href\", \"src\"\n    prefix (str): the prefix to replace e.g. \"/\", \"/images\", \"/thumbs\"\n    delim (str): if not None the delimiter for multiple values\n    \"\"\"\n    siteprefix = f\"/{self.frontend.name}{prefix}\"\n    if attribute in node.attrs:\n        attrval = node.attrs[attribute]\n        if delim is not None:\n            vals = attrval.split(delim)\n        else:\n            vals = [attrval]\n            delim = \"\"\n        newvals = []\n        for val in vals:\n            if val.startswith(prefix):\n                newvals.append(val.replace(prefix, siteprefix, 1))\n            else:\n                newvals.append(val)\n        if delim is not None:\n            node.attrs[attribute] = delim.join(newvals)\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.fix_images_and_videos","title":"<code>fix_images_and_videos(soup)</code>","text":"<p>fix image and video entries in the source code</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def fix_images_and_videos(self, soup):\n    \"\"\"\n    fix image and video entries in the source code\n    \"\"\"\n    for img in soup.findAll(\"img\"):\n        self.fixNode(img, \"src\", \"/\")\n        self.fixNode(img, \"srcset\", \"/\", \", \")\n    for video in soup.findAll(\"video\"):\n        for source in video.findAll(\"source\"):\n            self.fixNode(source, \"src\", \"/\")\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.getContent","title":"<code>getContent(pagePath)</code>","text":"<p>get the content for the given pagePath Args:     pagePath(str): the pagePath     whatToFilter(list): list of filter keys Returns:     str: the HTML content for the given path</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def getContent(self, pagePath: str):\n    \"\"\"get the content for the given pagePath\n    Args:\n        pagePath(str): the pagePath\n        whatToFilter(list): list of filter keys\n    Returns:\n        str: the HTML content for the given path\n    \"\"\"\n    content = None\n    error = None\n    pageTitle = \"?\"\n    try:\n        if pagePath == \"/\":\n            pageTitle = self.frontend.defaultPage\n        else:\n            error = self.checkPath(pagePath)\n            pageTitle = self.wikiPage(pagePath)\n        if error is None:\n            if self.wiki is None:\n                raise Exception(\n                    \"getContent without wiki - you might want to call open first\"\n                )\n            content = self.wiki.getHtml(pageTitle)\n            soup = self.filter(content)\n            soup = self.fixHtml(soup)\n            content = self.unwrap(soup)\n    except Exception as e:\n        error = self.errMsg(e)\n    return pageTitle, content, error\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.get_cms_pages","title":"<code>get_cms_pages()</code>","text":"<p>get the Content Management elements for this site</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def get_cms_pages(self) -&gt; dict:\n    \"\"\"\n    get the Content Management elements for this site\n    \"\"\"\n    cms_pages = {}\n    ask_query = \"[[Category:CMS]]\"\n    page_records = self.smwclient.query(ask_query, \"cms pages\")\n    for page_title in list(page_records):\n        page_title, html, error = self.getContent(page_title)\n        if not error:\n            cms_pages[page_title] = html\n        else:\n            self.logger.warn(error)\n    return cms_pages\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.get_frame","title":"<code>get_frame(page_title)</code>","text":"<p>get the frame property for the given page_title</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def get_frame(self, page_title: str) -&gt; str:\n    \"\"\"\n    get the frame property for the given page_title\n    \"\"\"\n    frame = None\n    markup = self.wiki.get_wiki_markup(page_title)\n    # {{#set:frame=reveal}}\n    # {{UseFrame|Contact.rythm|\n    patterns = [\n        r\"{{#set:frame=([^}]+)}}\",  # {{#set:frame=reveal}}\n        r\"{{UseFrame\\|([^.]+)\",  # {{UseFrame|Contact.rythm|\n    ]\n\n    for pattern in patterns:\n        match = re.search(pattern, markup)\n        if match:\n            frame = match.group(1)\n    return frame\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.get_path_response","title":"<code>get_path_response(path)</code>","text":"<p>get the repsonse for the the given path</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to render the content for</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>str</code> <p>a FastAPI response</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def get_path_response(self, path: str) -&gt; str:\n    \"\"\"\n    get the repsonse for the the given path\n\n    Args:\n        path(str): the path to render the content for\n\n    Returns:\n        Response: a FastAPI response\n    \"\"\"\n    if self.needsProxy(path):\n        html_response = self.proxy(path)\n        # Create a FastAPI response object\n        response = Response(\n            content=html_response.content,\n            status_code=html_response.status_code,\n            headers=dict(html_response.headers),\n        )\n    else:\n        page_title, content, error = self.getContent(path)\n        html_frame = HtmlFrame(self, title=page_title)\n        html = content\n        framed_html = None\n        if error:\n            html = f\"error getting {page_title} for {self.name}:&lt;br&gt;{error}\"\n        else:\n            if \"&lt;slideshow\" in html or \"&amp;lt;slideshow\" in html:\n                content = self.toReveal(content)\n                # Complete reveal.js webpage\n                framed_html = self.wrapWithReveal(html)\n                html = content\n\n        if not framed_html:\n            framed_html = html_frame.frame(html)\n        response = HTMLResponse(framed_html)\n    return response\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.log","title":"<code>log(msg)</code>","text":"<p>log the given message if debugging is true</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>the message to log</p> required Source code in <code>frontend/wikicms.py</code> <pre><code>def log(self, msg: str):\n    \"\"\"\n    log the given message if debugging is true\n\n    Args:\n        msg (str): the message to log\n    \"\"\"\n    if self.debug:\n        print(msg, flush=True)\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.needsProxy","title":"<code>needsProxy(path)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the path to check</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this path needs to be proxied</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def needsProxy(self, path: str) -&gt; bool:\n    \"\"\"\n    Args:\n        path (str): the path to check\n\n    Returns:\n        bool: True if this path needs to be proxied\n    \"\"\"\n    needs_proxy = False\n    for prefix in self.proxy_prefixes:\n        needs_proxy = needs_proxy or path.startswith(prefix)\n    return needs_proxy\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.open","title":"<code>open()</code>","text":"<p>open the frontend</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def open(self):\n    \"\"\"\n    open the frontend\n\n    \"\"\"\n    if self.wiki is None:\n        self.wiki = WikiClient.ofWikiId(self.frontend.wikiId)\n        if WikiFrontend.with_login:\n            self.wiki.login()\n        self.smwclient = SMWClient(self.wiki.getSite())\n        self.cms_pages = self.get_cms_pages()\n        self.frontend.enabled = True\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.proxy","title":"<code>proxy(path)</code>","text":"<p>Proxy a request. See https://stackoverflow.com/a/50231825/1497139</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the path to proxy</p> required <p>Returns:</p> Type Description <code>str</code> <p>the proxied result as a string</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def proxy(self, path: str) -&gt; str:\n    \"\"\"\n    Proxy a request.\n    See https://stackoverflow.com/a/50231825/1497139\n\n    Args:\n        path (str): the path to proxy\n\n    Returns:\n        the proxied result as a string\n    \"\"\"\n    wikiUser = self.wiki.wikiUser\n    url = f\"{wikiUser.url}{wikiUser.scriptPath}{path}\"\n\n    # Get the response\n    response = requests.get(url)\n\n    return response\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.toReveal","title":"<code>toReveal(html)</code>","text":"<p>convert the given html to reveal see https://revealjs.com/</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def toReveal(self, html: str):\n    \"\"\"\n    convert the given html to reveal\n    see https://revealjs.com/\n    \"\"\"\n    soup = BeautifulSoup(html, \"lxml\")\n    for h2 in soup.findChildren(recursive=True):\n        if h2.name == \"h2\":\n            span = h2.next_element\n            if span.name == \"span\":\n                tagid = span.get(\"id\")\n                if tagid.startswith(\"\u2318\u2318\"):\n                    section = soup.new_tag(\"section\")\n                    h2.parent.append(section)\n                    section.insert(0, h2)\n                    tag = h2.next_element\n                    while tag is not None and tag.name != \"h2\":\n                        if tag.parent != h2:\n                            section.append(tag)\n                        tag = tag.next_element\n    html = self.unwrap(soup)\n    return html\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.unwrap","title":"<code>unwrap(soup)</code>","text":"<p>unwrap the soup</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def unwrap(self, soup) -&gt; str:\n    \"\"\"\n    unwrap the soup\n    \"\"\"\n    html = str(soup)\n    html = html.replace(\"&lt;html&gt;&lt;body&gt;\", \"\")\n    html = html.replace(\"&lt;/body&gt;&lt;/html&gt;\", \"\")\n    # Remove  empty paragraphs\n    html = re.sub(r'&lt;p class=\"mw-empty-elt\"&gt;\\s*&lt;/p&gt;', \"\", html)\n\n    # Replace multiple newline characters with a single newline character\n    html = re.sub(r\"\\n\\s*\\n\", \"\\n\", html)\n    return html\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.wikiPage","title":"<code>wikiPage(pagePath)</code>","text":"<p>Get the wiki page for the given page path.</p> <p>Parameters:</p> Name Type Description Default <code>pagePath</code> <code>str</code> <p>The path of the page.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The title of the page.</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def wikiPage(self, pagePath: str) -&gt; str:\n    \"\"\"\n    Get the wiki page for the given page path.\n\n    Args:\n        pagePath (str): The path of the page.\n\n    Returns:\n        str: The title of the page.\n    \"\"\"\n    if \"/index.php/\" in pagePath:\n        wikipage = pagePath.replace(\"/index.php/\", \"\")\n    elif pagePath.startswith(\"/\"):\n        wikipage = pagePath[1:]\n    else:\n        wikipage = pagePath\n    return wikipage\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontend.wrapWithReveal","title":"<code>wrapWithReveal(html)</code>","text":"<p>wrap html content with reveal.js structure and dependencies</p> Source code in <code>frontend/wikicms.py</code> <pre><code>    def wrapWithReveal(self, html: str):\n        \"\"\"\n        wrap html content with reveal.js structure and dependencies\n        \"\"\"\n        wrapped_html = f\"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.min.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/white.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"reveal\"&gt;\n        &lt;div class=\"slides\"&gt;\n{html}\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;Reveal.initialize({{\n    }});&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n        return wrapped_html\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontends","title":"<code>WikiFrontends</code>","text":"<p>wiki frontends</p> Source code in <code>frontend/wikicms.py</code> <pre><code>class WikiFrontends:\n    \"\"\"\n    wiki frontends\n    \"\"\"\n\n    def __init__(self, servers):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.servers = servers\n        self.wiki_frontends = {}\n\n    def enableSites(self, siteNames):\n        \"\"\"\n        enable the sites given in the sites list\n        Args:\n            siteNames(list): a list of strings with wikiIds to be enabled\n        \"\"\"\n        if siteNames is None:\n            return\n        for siteName in siteNames:\n            self.get_frontend(siteName)\n\n    def get_frontend(self, name: str) -&gt; WikiFrontend:\n        \"\"\"\n        Get WikiFrontend from cache or create new one\n        \"\"\"\n        # Check cache first\n        if name in self.wiki_frontends:\n            cached_frontend = self.wiki_frontends[name]\n            return cached_frontend\n\n        # Create new frontend if not cached\n        frontend = self.servers.frontends_by_name.get(name)\n        if frontend:\n            wiki_frontend = WikiFrontend(frontend)\n            wiki_frontend.open()\n            # Cache it\n            self.wiki_frontends[name] = wiki_frontend\n            return wiki_frontend\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontends.__init__","title":"<code>__init__(servers)</code>","text":"<p>constructor</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def __init__(self, servers):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.servers = servers\n    self.wiki_frontends = {}\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontends.enableSites","title":"<code>enableSites(siteNames)</code>","text":"<p>enable the sites given in the sites list Args:     siteNames(list): a list of strings with wikiIds to be enabled</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def enableSites(self, siteNames):\n    \"\"\"\n    enable the sites given in the sites list\n    Args:\n        siteNames(list): a list of strings with wikiIds to be enabled\n    \"\"\"\n    if siteNames is None:\n        return\n    for siteName in siteNames:\n        self.get_frontend(siteName)\n</code></pre>"},{"location":"#frontend.wikicms.WikiFrontends.get_frontend","title":"<code>get_frontend(name)</code>","text":"<p>Get WikiFrontend from cache or create new one</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def get_frontend(self, name: str) -&gt; WikiFrontend:\n    \"\"\"\n    Get WikiFrontend from cache or create new one\n    \"\"\"\n    # Check cache first\n    if name in self.wiki_frontends:\n        cached_frontend = self.wiki_frontends[name]\n        return cached_frontend\n\n    # Create new frontend if not cached\n    frontend = self.servers.frontends_by_name.get(name)\n    if frontend:\n        wiki_frontend = WikiFrontend(frontend)\n        wiki_frontend.open()\n        # Cache it\n        self.wiki_frontends[name] = wiki_frontend\n        return wiki_frontend\n</code></pre>"},{"location":"#frontend.wikigrid","title":"<code>wikigrid</code>","text":"<p>Created on 2022-12-03</p> <p>@author: wf</p>"},{"location":"#frontend.wikigrid.WikiCheck","title":"<code>WikiCheck</code>","text":"<p>Check to be performed on  a Mediawiki.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>class WikiCheck:\n    \"\"\"\n    Check to be performed on  a Mediawiki.\n    \"\"\"\n\n    def __init__(self, name, func, checked=True):\n        self.name = name\n        self.func = func  # the check function to be performed on a WikiState\n        self.checked = checked\n        self.checkbox = None\n\n    def as_checkbox(self):\n        \"\"\"\n        Return a checkbox representation of the instance.\n        \"\"\"\n        self.checkbox = ui.checkbox(self.name).bind_value(self, \"checked\")\n        return self.checkbox\n</code></pre>"},{"location":"#frontend.wikigrid.WikiCheck.as_checkbox","title":"<code>as_checkbox()</code>","text":"<p>Return a checkbox representation of the instance.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def as_checkbox(self):\n    \"\"\"\n    Return a checkbox representation of the instance.\n    \"\"\"\n    self.checkbox = ui.checkbox(self.name).bind_value(self, \"checked\")\n    return self.checkbox\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid","title":"<code>WikiGrid</code>","text":"<p>A grid of Wikis.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>class WikiGrid:\n    \"\"\"\n    A grid of Wikis.\n    \"\"\"\n\n    def __init__(self, solution):\n        # back reference to nicegui solution\n        self.solution = solution\n\n        self.wiki_users = WikiUser.getWikiUsers()\n        self.wiki_clients = {}\n        self.smw_clients = {}\n        self.sorted_wiki_users = sorted(\n            self.wiki_users.values(), key=lambda w: w.wikiId\n        )\n        self.lod = []\n        self.task_runner = TaskRunner(timeout=40)\n        self.wikistates_by_row_no = {}\n        for index, wiki_user in enumerate(self.sorted_wiki_users):\n            wiki_state = MediaWikiSite(wiki_user=wiki_user, row_index=index)\n            record = wiki_state.as_dict()\n            self.lod.append(record)\n            self.wikistates_by_row_no[wiki_state.row_no] = wiki_state\n\n    def setup(self):\n        \"\"\"\n        setup the ui\n        \"\"\"\n        self.add_checkboxes()\n        self.progressbar = NiceguiProgressbar(\n            len(self.wikistates_by_row_no), \"work on wikis\", \"steps\"\n        )\n        self.task_runner.progress = self.progressbar\n        self.as_grid()\n        self.lod_grid.update()\n\n    def as_grid(self):\n        # Configure grid with checkbox selection\n        grid_config = GridConfig(\n            key_col=\"#\",\n            editable=False,\n            multiselect=True,\n            with_buttons=True,\n            button_names=[\"all\", \"fit\"],\n            debug=False,\n        )\n        self.lod_grid = ListOfDictsGrid(lod=self.lod, config=grid_config)\n        self.lod_grid.ag_grid._props[\"html_columns\"] = [0, 1, 2]\n        return self.lod_grid\n\n    def add_checkboxes(self):\n        \"\"\"\n        Add check boxes.\n        \"\"\"\n        self.button_row = ui.row()\n        with self.button_row:\n            self.wiki_checks = [\n                WikiCheck(\"version\", self.check_wiki_version),\n                WikiCheck(\"backup\", self.check_backup),\n                WikiCheck(\"pages\", self.check_pages),\n            ]\n            for wiki_check in self.wiki_checks:\n                wiki_check.as_checkbox()\n            ui.button(text=\"Checks\", on_click=self.perform_wiki_checks)\n\n    async def get_selected_lod(self):\n        lod_index = self.lod_grid.get_index(\n            lenient=self.lod_grid.config.lenient, lod=self.lod\n        )\n        lod = await self.lod_grid.get_selected_lod(lod_index=lod_index)\n        if len(lod) == 0:\n            with self.button_row:\n                ui.notify(\"Please select at least one row\")\n        return lod\n\n    async def perform_wiki_checks(self, _msg):\n        \"\"\"\n        react on the button for check having been clicked\n        \"\"\"\n        self.select_lod = await self.get_selected_lod()\n        if self.select_lod:\n            with self.solution.content_div:\n                total = len(self.select_lod)\n                ui.notify(f\"Checking {total} wikis ...\")\n                # Use single task_runner\n                self.task_runner.run_blocking(self.run_all_wiki_checks)\n\n    def run_all_wiki_checks(self):\n        \"\"\"\n        Process all selected wikis sequentially\n        \"\"\"\n        try:\n            # Calculate total steps\n            steps = 0\n            for wiki_check in self.wiki_checks:\n                if wiki_check.checked:\n                    steps += len(self.select_lod)\n            self.progressbar.total = steps\n            self.progressbar.reset()\n\n            # Process each wiki sequentially\n            for row in self.select_lod:\n                row_no = row[\"#\"]\n                wiki_state = self.wikistates_by_row_no.get(row_no)\n                self.run_wiki_check(wiki_state)\n\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def run_wiki_check(self, wiki_state):\n        \"\"\"\n        perform the selected wiki checks for a single wiki\n        \"\"\"\n        try:\n            for wiki_check in self.wiki_checks:\n                if wiki_check.checked:\n                    wiki_check.func(wiki_state)\n                with self.solution.content_div:\n                    self.lod_grid.update()\n                    # Update the progress bar\n                    self.progressbar.update(1)\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def check_pages(self, wiki_state: MediaWikiSite):\n        \"\"\"\n        Try login for wiki user and report success or failure.\n        \"\"\"\n        try:\n            try:\n                client = wiki_state.wiki_client\n                stats = client.get_site_statistics()\n                pages = stats[\"pages\"]\n                self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u2705\")\n                self.lod_grid.update_cell(wiki_state.row_no, \"pages\", f\"\u2705{pages}\")\n            except Exception as ex:\n                self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u274c {str(ex)}\")\n                self.lod_grid.update_cell(wiki_state.row_no, \"pages\", \"\u274c\")\n                return\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def check_wiki_version(self, wiki_state: MediaWikiSite):\n        \"\"\"\n        Check the MediaWiki version for a specific WikiState.\n        \"\"\"\n        try:\n            mw_version = wiki_state.check_version()\n            if not mw_version.startswith(\"MediaWiki\"):\n                mw_version = f\"MediaWiki {mw_version}\"\n            row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n            if row:\n                ex_version = wiki_state.wiki_user.version\n                if ex_version == mw_version:\n                    self.lod_grid.update_cell(\n                        wiki_state.row_no, \"version\", f\"{mw_version}\u2705\"\n                    )\n                else:\n                    self.lod_grid.update_cell(\n                        wiki_state.row_no, \"version\", f\"{ex_version}!={mw_version}\u274c\"\n                    )\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def check_backup(self, wiki_state):\n        \"\"\"\n        Check the backup status for a specific WikiUser.\n        \"\"\"\n        try:\n            row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n            if row:\n                backup_path = f\"{Path.home()}/wikibackup/{wiki_state.wiki_user.wikiId}\"\n                if os.path.isdir(backup_path):\n                    wiki_files = glob.glob(f\"{backup_path}/*.wiki\")\n                    msg = f\"{len(wiki_files):6} \u2705\"\n                    self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n                    # https://stackoverflow.com/a/39327156/1497139\n                    if wiki_files:\n                        latest_file = max(wiki_files, key=os.path.getctime)\n                        st = os.stat(latest_file)\n                        age_days = round((time.time() - st.st_mtime) / 86400)\n                        self.lod_grid.update_cell(\n                            wiki_state.row_no, \"age\", f\"{age_days}\"\n                        )\n                else:\n                    msg = \"\u274c\"\n                    self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.add_checkboxes","title":"<code>add_checkboxes()</code>","text":"<p>Add check boxes.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def add_checkboxes(self):\n    \"\"\"\n    Add check boxes.\n    \"\"\"\n    self.button_row = ui.row()\n    with self.button_row:\n        self.wiki_checks = [\n            WikiCheck(\"version\", self.check_wiki_version),\n            WikiCheck(\"backup\", self.check_backup),\n            WikiCheck(\"pages\", self.check_pages),\n        ]\n        for wiki_check in self.wiki_checks:\n            wiki_check.as_checkbox()\n        ui.button(text=\"Checks\", on_click=self.perform_wiki_checks)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_backup","title":"<code>check_backup(wiki_state)</code>","text":"<p>Check the backup status for a specific WikiUser.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_backup(self, wiki_state):\n    \"\"\"\n    Check the backup status for a specific WikiUser.\n    \"\"\"\n    try:\n        row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n        if row:\n            backup_path = f\"{Path.home()}/wikibackup/{wiki_state.wiki_user.wikiId}\"\n            if os.path.isdir(backup_path):\n                wiki_files = glob.glob(f\"{backup_path}/*.wiki\")\n                msg = f\"{len(wiki_files):6} \u2705\"\n                self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n                # https://stackoverflow.com/a/39327156/1497139\n                if wiki_files:\n                    latest_file = max(wiki_files, key=os.path.getctime)\n                    st = os.stat(latest_file)\n                    age_days = round((time.time() - st.st_mtime) / 86400)\n                    self.lod_grid.update_cell(\n                        wiki_state.row_no, \"age\", f\"{age_days}\"\n                    )\n            else:\n                msg = \"\u274c\"\n                self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_pages","title":"<code>check_pages(wiki_state)</code>","text":"<p>Try login for wiki user and report success or failure.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_pages(self, wiki_state: MediaWikiSite):\n    \"\"\"\n    Try login for wiki user and report success or failure.\n    \"\"\"\n    try:\n        try:\n            client = wiki_state.wiki_client\n            stats = client.get_site_statistics()\n            pages = stats[\"pages\"]\n            self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u2705\")\n            self.lod_grid.update_cell(wiki_state.row_no, \"pages\", f\"\u2705{pages}\")\n        except Exception as ex:\n            self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u274c {str(ex)}\")\n            self.lod_grid.update_cell(wiki_state.row_no, \"pages\", \"\u274c\")\n            return\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_wiki_version","title":"<code>check_wiki_version(wiki_state)</code>","text":"<p>Check the MediaWiki version for a specific WikiState.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_wiki_version(self, wiki_state: MediaWikiSite):\n    \"\"\"\n    Check the MediaWiki version for a specific WikiState.\n    \"\"\"\n    try:\n        mw_version = wiki_state.check_version()\n        if not mw_version.startswith(\"MediaWiki\"):\n            mw_version = f\"MediaWiki {mw_version}\"\n        row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n        if row:\n            ex_version = wiki_state.wiki_user.version\n            if ex_version == mw_version:\n                self.lod_grid.update_cell(\n                    wiki_state.row_no, \"version\", f\"{mw_version}\u2705\"\n                )\n            else:\n                self.lod_grid.update_cell(\n                    wiki_state.row_no, \"version\", f\"{ex_version}!={mw_version}\u274c\"\n                )\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.perform_wiki_checks","title":"<code>perform_wiki_checks(_msg)</code>  <code>async</code>","text":"<p>react on the button for check having been clicked</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>async def perform_wiki_checks(self, _msg):\n    \"\"\"\n    react on the button for check having been clicked\n    \"\"\"\n    self.select_lod = await self.get_selected_lod()\n    if self.select_lod:\n        with self.solution.content_div:\n            total = len(self.select_lod)\n            ui.notify(f\"Checking {total} wikis ...\")\n            # Use single task_runner\n            self.task_runner.run_blocking(self.run_all_wiki_checks)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.run_all_wiki_checks","title":"<code>run_all_wiki_checks()</code>","text":"<p>Process all selected wikis sequentially</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def run_all_wiki_checks(self):\n    \"\"\"\n    Process all selected wikis sequentially\n    \"\"\"\n    try:\n        # Calculate total steps\n        steps = 0\n        for wiki_check in self.wiki_checks:\n            if wiki_check.checked:\n                steps += len(self.select_lod)\n        self.progressbar.total = steps\n        self.progressbar.reset()\n\n        # Process each wiki sequentially\n        for row in self.select_lod:\n            row_no = row[\"#\"]\n            wiki_state = self.wikistates_by_row_no.get(row_no)\n            self.run_wiki_check(wiki_state)\n\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.run_wiki_check","title":"<code>run_wiki_check(wiki_state)</code>","text":"<p>perform the selected wiki checks for a single wiki</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def run_wiki_check(self, wiki_state):\n    \"\"\"\n    perform the selected wiki checks for a single wiki\n    \"\"\"\n    try:\n        for wiki_check in self.wiki_checks:\n            if wiki_check.checked:\n                wiki_check.func(wiki_state)\n            with self.solution.content_div:\n                self.lod_grid.update()\n                # Update the progress bar\n                self.progressbar.update(1)\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.setup","title":"<code>setup()</code>","text":"<p>setup the ui</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def setup(self):\n    \"\"\"\n    setup the ui\n    \"\"\"\n    self.add_checkboxes()\n    self.progressbar = NiceguiProgressbar(\n        len(self.wikistates_by_row_no), \"work on wikis\", \"steps\"\n    )\n    self.task_runner.progress = self.progressbar\n    self.as_grid()\n    self.lod_grid.update()\n</code></pre>"}]}