{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyWikiCMS API Documentation","text":""},{"location":"#frontend.clickstream","title":"<code>clickstream</code>","text":"<p>Created on 2023-06-11</p> <p>@author: wf</p>"},{"location":"#frontend.clickstream.ClickStream","title":"<code>ClickStream</code>  <code>dataclass</code>","text":"<p>Represents a clickstream with associated page hits and user agent data.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass ClickStream:\n    \"\"\"Represents a clickstream with associated page hits and user agent data.\"\"\"\n\n    url: str\n    ip: str\n    domain: str\n    timeStamp: datetime\n    pageHits: List[PageHit]\n    userAgent: UserAgent\n    userAgentHeader: Optional[str] = None\n    referrer: Optional[str] = None\n    acceptLanguage: Optional[str] = None\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"ClickStream\":\n        data[\"timeStamp\"] = DateParse.parse_date(data[\"timeStamp\"])\n        # Ensure `pageHits` are processed into PageHit instances\n        # Initialize an empty list to store PageHit instances.\n        page_hits = []\n\n        # Iterate through each item in the list obtained from the 'pageHits' key.\n        # Using .get() with a default empty list to handle the absence of 'pageHits'.\n        for hit in data.get(\"pageHits\", []):\n            # Check if the current hit is not None before processing.\n            if hit is not None:\n                # Convert the hit dictionary to a PageHit instance and add it to the list.\n                page_hits.append(PageHit.from_dict(hit))\n\n        # 'data' dictionary is updated to hold the list of PageHit instances.\n        data[\"pageHits\"] = page_hits\n        # Remove any keys from `data` that are not fields of the `ClickStream` dataclass\n        # data = {key: value for key, value in data.items() if key in ClickStream.__annotations__}\n\n        # Let the `_postprocess` handle the userAgent conversion\n        data = ClickStream._postprocess(data)\n        return ClickStream(**data)\n\n    @staticmethod\n    def _postprocess(data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        # Ensure `userAgent` is a dictionary before trying to convert\n        if isinstance(data.get(\"userAgent\"), dict):\n            data[\"userAgent\"] = UserAgent.from_dict(data[\"userAgent\"])\n        # If `pageHits` needs to be processed again (not typically necessary if handled in `from_dict`)\n        if isinstance(data.get(\"pageHits\"), list):\n            data[\"pageHits\"] = [\n                PageHit.from_dict(hit) if isinstance(hit, dict) else hit\n                for hit in data[\"pageHits\"]\n            ]\n        return data\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamLog","title":"<code>ClickstreamLog</code>  <code>dataclass</code>","text":"<p>single log of clickstreams</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass ClickstreamLog:\n    \"\"\"\n    single log of clickstreams\n    \"\"\"\n\n    debug: bool\n    MAX_CLICKSTREAMS: int\n    LOGGING_TIME_PERIOD: int\n    MAX_SESSION_TIME: int\n    FLUSH_PERIOD: int\n    startTime: datetime\n    lastFlush: datetime\n    lastLogRotate: datetime\n    fileName: str\n    clickStreams: List[ClickStream]\n\n    @classmethod\n    def from_json(cls, json_file: str):\n        with open(json_file, \"r\", encoding=\"utf-8\") as file:\n            data = json.load(file)\n\n        # Handle nested structures\n        data = ClickstreamLog._postprocess(data)\n\n        return ClickstreamLog(**data)\n\n    @classmethod\n    def _postprocess(cls, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        data[\"startTime\"] = DateParse.parse_date(data[\"startTime\"])\n        data[\"lastFlush\"] = DateParse.parse_date(data[\"lastFlush\"])\n        data[\"lastLogRotate\"] = DateParse.parse_date(data[\"lastLogRotate\"])\n        data[\"clickStreams\"] = [\n            ClickStream.from_dict(cs) for cs in data.get(\"clickStreams\", [])\n        ]\n        return data\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager","title":"<code>ClickstreamManager</code>","text":"<p>               Bases: <code>object</code></p> <p>logging of client clicks</p> Source code in <code>frontend/clickstream.py</code> <pre><code>class ClickstreamManager(object):\n    \"\"\"\n    logging of client clicks\n    \"\"\"\n\n    def __init__(\n        self,\n        root_path: str,\n        rdf_namespace=\"http://cms.bitplan.com/clickstream#\",\n        show_progress: bool = True,\n        verbose: bool = True,\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            rdf_namespace(str): The base namespace URI for the RDF export.\n            verbose(bool): If True, print the output message.\n        \"\"\"\n        self.root_path = root_path\n        self.rdf_namespace = rdf_namespace\n        self.clickstream_logs: List[ClickstreamLog] = []\n        self.show_progress = show_progress\n        self.verbose = verbose\n\n    def get_progress(self, iterable, desc=\"Processing\"):\n        \"\"\"\n        Wrap an iterable with a progress bar if show_progress is True\n        \"\"\"\n        if self.show_progress:\n            return tqdm(iterable, desc=desc)\n        else:\n            return iterable\n\n    def load_clickstream_logs(self, limit: Optional[int] = None) -&gt; None:\n        \"\"\"\n        Load all clickstream logs from the directory\n        \"\"\"\n        # Find all json files in the directory\n        json_files = glob.glob(os.path.join(self.root_path, \"*.json\"))\n        # If a limit is set, truncate the file list\n        if limit is not None:\n            json_files = json_files[:limit]\n\n        # Prepare tqdm iterator if required and tqdm is available\n        iterator = self.get_progress(json_files, desc=\"Loading Clickstream Logs\")\n\n        total_clickstreams = 0\n\n        # Load each file\n\n        for json_file in iterator:\n            try:\n                # Parse the JSON file into ClickstreamLog\n                clickstream_log = ClickstreamLog.from_json(json_file)\n                self.clickstream_logs.append(clickstream_log)\n                total_clickstreams += len(\n                    clickstream_log.clickStreams\n                )  # Count the clickstreams\n            except json.JSONDecodeError as jde:\n                # Handle JSON-specific parsing errors\n                print(f\"JSON decode error in file {json_file}: {jde.msg}\")\n                print(f\"Error at line {jde.lineno}, column {jde.colno}\")\n            except Exception as e:\n                tb = traceback.format_exc()  # This will give you the stack trace\n                print(f\"Error loading {json_file}: {e}\")\n                print(tb)  # Print stack trace to get more details about the exception\n        # After importing, show the total counts\n        total_logs = len(self.clickstream_logs)\n        print(\n            f\"Imported {total_logs} clickstream logs with a total of {total_clickstreams} clickstreams.\"\n        )\n\n    def serialize_batch(\n        self, g: Graph, rdf_file: str, file_counter: int, rdf_format: str\n    ) -&gt; None:\n        \"\"\"\n        Serializes a batch of RDF data to a file.\n\n        Args:\n            g (Graph): The RDF graph to serialize.\n            rdf_file (str): The base name for the RDF file.\n            file_counter (int): The current file count for naming.\n            rdf_format (str): The format to serialize the RDF data.\n\n        \"\"\"\n        batch_file = f\"{rdf_file}_part{file_counter:03}.{rdf_format}\"\n        g.serialize(destination=batch_file, format=rdf_format)\n        if self.verbose:\n            print(f\"Exported RDF to {batch_file}\")\n\n    def add_stream_properties_to_graph(\n        self, g: Graph, CS: Namespace, stream: Any, entity_counter: int\n    ) -&gt; int:\n        \"\"\"\n        Adds the properties of a clickstream to the RDF graph.\n\n        Args:\n            g (Graph): The graph to which the properties will be added.\n            CS (Namespace): The namespace for clickstream data.\n            stream (Any): The clickstream object containing the data.\n            entity_counter (int): A counter for creating unique entities.\n\n        Returns:\n            int: The updated entity counter after adding the properties.\n        \"\"\"\n        stream_uri = URIRef(f\"{CS}clickstream/{entity_counter}\")\n        entity_counter += 1\n\n        # Add properties to the stream URI\n        g.add((stream_uri, RDF.type, CS.ClickStream))\n        g.add((stream_uri, CS.url, Literal(stream.url)))\n        g.add((stream_uri, CS.ip, Literal(stream.ip)))\n        g.add((stream_uri, CS.domain, Literal(stream.domain)))\n        g.add((stream_uri, CS.userAgentHeader, Literal(stream.userAgentHeader)))\n        g.add(\n            (\n                stream_uri,\n                CS.timeStamp,\n                Literal(stream.timeStamp.isoformat(), datatype=XSD.dateTime),\n            )\n        )\n\n        # Optional referrer information\n        if stream.referrer:\n            g.add((stream_uri, CS.referrer, Literal(stream.referrer)))\n\n        # User Agent details\n        ua_uri = URIRef(f\"{CS}useragent/{entity_counter}\")\n        entity_counter += 1\n        g.add((ua_uri, RDF.type, CS.UserAgent))\n        g.add((ua_uri, CS.hasSyntaxError, Literal(stream.userAgent.hasSyntaxError)))\n        g.add((ua_uri, CS.hasAmbiguity, Literal(stream.userAgent.hasAmbiguity)))\n        g.add((ua_uri, CS.ambiguityCount, Literal(stream.userAgent.ambiguityCount)))\n        g.add((ua_uri, CS.userAgentString, Literal(stream.userAgent.userAgentString)))\n        g.add((stream_uri, CS.userAgent, ua_uri))\n\n        # Page Hits\n        for hit in stream.pageHits:\n            hit_uri = URIRef(f\"{CS}pagehit/{entity_counter}\")\n            entity_counter += 1\n            g.add((hit_uri, RDF.type, CS.PageHit))\n            g.add((hit_uri, CS.path, Literal(hit.path)))\n            g.add(\n                (\n                    hit_uri,\n                    CS.timeStamp,\n                    Literal(hit.timeStamp.isoformat(), datatype=XSD.dateTime),\n                )\n            )\n            g.add((stream_uri, CS.pageHits, hit_uri))\n\n        return entity_counter\n\n    def export_to_rdf(\n        self,\n        rdf_file: str,\n        batch_size: int,\n        rdf_format: str = \"nt\",\n    ) -&gt; None:\n        \"\"\"\n        Export clickstream logs to RDF files in batches.\n        :param rdf_file: The base file name to write the RDF data to.\n        :param batch_size: The number of clickstream records per file.\n        :param rdf_format: The RDF serialization format to use (default is \"nt\").\n        \"\"\"\n        # Namespace definition\n        CS = Namespace(self.rdf_namespace)\n\n        # Initialize variables\n        file_counter = 1\n        entity_counter = 1\n        g = Graph()\n        g.bind(\"cs\", CS)\n\n        # Create the directory if it doesn't exist\n        os.makedirs(os.path.dirname(rdf_file), exist_ok=True)\n        iterator = self.get_progress(self.clickstream_logs, desc=\"Export Progress\")\n\n        for log in iterator:\n            for stream in log.clickStreams:\n                entity_counter = self.add_stream_properties_to_graph(\n                    g, CS, stream, entity_counter\n                )\n\n                # If batch size is reached, serialize and save to file\n                if entity_counter % batch_size == 0:\n                    self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n                    file_counter += 1\n                    g = Graph()  # Reset the graph for the next batch\n                    g.bind(\"cs\", CS)\n\n        # Serialize and save any remaining triples that didn't fill up the last batch\n        if len(g):\n            self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n\n    def reload_graph(self, rdf_file_pattern: str, rdf_format: str = \"nt\") -&gt; Graph:\n        \"\"\"\n        Reloads the RDF data from a batch of files into the clickstream logs.\n\n        Args:\n            rdf_file_pattern (str): The file pattern to search for RDF files.\n                                    A wildcard '*' will be appended if not present.\n            rdf_format (str): The RDF serialization format of the files (default is \"nt\").\n\n        Returns:\n            Graph: The RDF graph populated with data from the files.\n        \"\"\"\n        # Ensure the pattern ends with a wildcard, append if necessary\n        if not rdf_file_pattern.endswith(\"*\"):\n            rdf_file_pattern += \"*\"\n\n        # Find all files matching the pattern\n        rdf_files = glob.glob(rdf_file_pattern)\n\n        # Initialize a new RDF graph\n        g = Graph()\n\n        # Use a progress bar if available or simply iterate over files\n        try:\n            iterator = self.get_progress(rdf_files, desc=\"Loading graph\")\n        except AttributeError:\n            # If get_progress is not defined, fall back to simple iteration\n            iterator = rdf_files\n\n        for rdf_file in iterator:\n            # Parse each RDF file and add it to the graph\n            g.parse(rdf_file, format=rdf_format)\n\n        # After loading all files, return the populated graph\n        return g\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.__init__","title":"<code>__init__(root_path, rdf_namespace='http://cms.bitplan.com/clickstream#', show_progress=True, verbose=True)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>rdf_namespace(str)</code> <p>The base namespace URI for the RDF export.</p> required <code>verbose(bool)</code> <p>If True, print the output message.</p> required Source code in <code>frontend/clickstream.py</code> <pre><code>def __init__(\n    self,\n    root_path: str,\n    rdf_namespace=\"http://cms.bitplan.com/clickstream#\",\n    show_progress: bool = True,\n    verbose: bool = True,\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        rdf_namespace(str): The base namespace URI for the RDF export.\n        verbose(bool): If True, print the output message.\n    \"\"\"\n    self.root_path = root_path\n    self.rdf_namespace = rdf_namespace\n    self.clickstream_logs: List[ClickstreamLog] = []\n    self.show_progress = show_progress\n    self.verbose = verbose\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.add_stream_properties_to_graph","title":"<code>add_stream_properties_to_graph(g, CS, stream, entity_counter)</code>","text":"<p>Adds the properties of a clickstream to the RDF graph.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Graph</code> <p>The graph to which the properties will be added.</p> required <code>CS</code> <code>Namespace</code> <p>The namespace for clickstream data.</p> required <code>stream</code> <code>Any</code> <p>The clickstream object containing the data.</p> required <code>entity_counter</code> <code>int</code> <p>A counter for creating unique entities.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The updated entity counter after adding the properties.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def add_stream_properties_to_graph(\n    self, g: Graph, CS: Namespace, stream: Any, entity_counter: int\n) -&gt; int:\n    \"\"\"\n    Adds the properties of a clickstream to the RDF graph.\n\n    Args:\n        g (Graph): The graph to which the properties will be added.\n        CS (Namespace): The namespace for clickstream data.\n        stream (Any): The clickstream object containing the data.\n        entity_counter (int): A counter for creating unique entities.\n\n    Returns:\n        int: The updated entity counter after adding the properties.\n    \"\"\"\n    stream_uri = URIRef(f\"{CS}clickstream/{entity_counter}\")\n    entity_counter += 1\n\n    # Add properties to the stream URI\n    g.add((stream_uri, RDF.type, CS.ClickStream))\n    g.add((stream_uri, CS.url, Literal(stream.url)))\n    g.add((stream_uri, CS.ip, Literal(stream.ip)))\n    g.add((stream_uri, CS.domain, Literal(stream.domain)))\n    g.add((stream_uri, CS.userAgentHeader, Literal(stream.userAgentHeader)))\n    g.add(\n        (\n            stream_uri,\n            CS.timeStamp,\n            Literal(stream.timeStamp.isoformat(), datatype=XSD.dateTime),\n        )\n    )\n\n    # Optional referrer information\n    if stream.referrer:\n        g.add((stream_uri, CS.referrer, Literal(stream.referrer)))\n\n    # User Agent details\n    ua_uri = URIRef(f\"{CS}useragent/{entity_counter}\")\n    entity_counter += 1\n    g.add((ua_uri, RDF.type, CS.UserAgent))\n    g.add((ua_uri, CS.hasSyntaxError, Literal(stream.userAgent.hasSyntaxError)))\n    g.add((ua_uri, CS.hasAmbiguity, Literal(stream.userAgent.hasAmbiguity)))\n    g.add((ua_uri, CS.ambiguityCount, Literal(stream.userAgent.ambiguityCount)))\n    g.add((ua_uri, CS.userAgentString, Literal(stream.userAgent.userAgentString)))\n    g.add((stream_uri, CS.userAgent, ua_uri))\n\n    # Page Hits\n    for hit in stream.pageHits:\n        hit_uri = URIRef(f\"{CS}pagehit/{entity_counter}\")\n        entity_counter += 1\n        g.add((hit_uri, RDF.type, CS.PageHit))\n        g.add((hit_uri, CS.path, Literal(hit.path)))\n        g.add(\n            (\n                hit_uri,\n                CS.timeStamp,\n                Literal(hit.timeStamp.isoformat(), datatype=XSD.dateTime),\n            )\n        )\n        g.add((stream_uri, CS.pageHits, hit_uri))\n\n    return entity_counter\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.export_to_rdf","title":"<code>export_to_rdf(rdf_file, batch_size, rdf_format='nt')</code>","text":"<p>Export clickstream logs to RDF files in batches. :param rdf_file: The base file name to write the RDF data to. :param batch_size: The number of clickstream records per file. :param rdf_format: The RDF serialization format to use (default is \"nt\").</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def export_to_rdf(\n    self,\n    rdf_file: str,\n    batch_size: int,\n    rdf_format: str = \"nt\",\n) -&gt; None:\n    \"\"\"\n    Export clickstream logs to RDF files in batches.\n    :param rdf_file: The base file name to write the RDF data to.\n    :param batch_size: The number of clickstream records per file.\n    :param rdf_format: The RDF serialization format to use (default is \"nt\").\n    \"\"\"\n    # Namespace definition\n    CS = Namespace(self.rdf_namespace)\n\n    # Initialize variables\n    file_counter = 1\n    entity_counter = 1\n    g = Graph()\n    g.bind(\"cs\", CS)\n\n    # Create the directory if it doesn't exist\n    os.makedirs(os.path.dirname(rdf_file), exist_ok=True)\n    iterator = self.get_progress(self.clickstream_logs, desc=\"Export Progress\")\n\n    for log in iterator:\n        for stream in log.clickStreams:\n            entity_counter = self.add_stream_properties_to_graph(\n                g, CS, stream, entity_counter\n            )\n\n            # If batch size is reached, serialize and save to file\n            if entity_counter % batch_size == 0:\n                self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n                file_counter += 1\n                g = Graph()  # Reset the graph for the next batch\n                g.bind(\"cs\", CS)\n\n    # Serialize and save any remaining triples that didn't fill up the last batch\n    if len(g):\n        self.serialize_batch(g, rdf_file, file_counter, rdf_format)\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.get_progress","title":"<code>get_progress(iterable, desc='Processing')</code>","text":"<p>Wrap an iterable with a progress bar if show_progress is True</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def get_progress(self, iterable, desc=\"Processing\"):\n    \"\"\"\n    Wrap an iterable with a progress bar if show_progress is True\n    \"\"\"\n    if self.show_progress:\n        return tqdm(iterable, desc=desc)\n    else:\n        return iterable\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.load_clickstream_logs","title":"<code>load_clickstream_logs(limit=None)</code>","text":"<p>Load all clickstream logs from the directory</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def load_clickstream_logs(self, limit: Optional[int] = None) -&gt; None:\n    \"\"\"\n    Load all clickstream logs from the directory\n    \"\"\"\n    # Find all json files in the directory\n    json_files = glob.glob(os.path.join(self.root_path, \"*.json\"))\n    # If a limit is set, truncate the file list\n    if limit is not None:\n        json_files = json_files[:limit]\n\n    # Prepare tqdm iterator if required and tqdm is available\n    iterator = self.get_progress(json_files, desc=\"Loading Clickstream Logs\")\n\n    total_clickstreams = 0\n\n    # Load each file\n\n    for json_file in iterator:\n        try:\n            # Parse the JSON file into ClickstreamLog\n            clickstream_log = ClickstreamLog.from_json(json_file)\n            self.clickstream_logs.append(clickstream_log)\n            total_clickstreams += len(\n                clickstream_log.clickStreams\n            )  # Count the clickstreams\n        except json.JSONDecodeError as jde:\n            # Handle JSON-specific parsing errors\n            print(f\"JSON decode error in file {json_file}: {jde.msg}\")\n            print(f\"Error at line {jde.lineno}, column {jde.colno}\")\n        except Exception as e:\n            tb = traceback.format_exc()  # This will give you the stack trace\n            print(f\"Error loading {json_file}: {e}\")\n            print(tb)  # Print stack trace to get more details about the exception\n    # After importing, show the total counts\n    total_logs = len(self.clickstream_logs)\n    print(\n        f\"Imported {total_logs} clickstream logs with a total of {total_clickstreams} clickstreams.\"\n    )\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.reload_graph","title":"<code>reload_graph(rdf_file_pattern, rdf_format='nt')</code>","text":"<p>Reloads the RDF data from a batch of files into the clickstream logs.</p> <p>Parameters:</p> Name Type Description Default <code>rdf_file_pattern</code> <code>str</code> <p>The file pattern to search for RDF files.                     A wildcard '*' will be appended if not present.</p> required <code>rdf_format</code> <code>str</code> <p>The RDF serialization format of the files (default is \"nt\").</p> <code>'nt'</code> <p>Returns:</p> Name Type Description <code>Graph</code> <code>Graph</code> <p>The RDF graph populated with data from the files.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>def reload_graph(self, rdf_file_pattern: str, rdf_format: str = \"nt\") -&gt; Graph:\n    \"\"\"\n    Reloads the RDF data from a batch of files into the clickstream logs.\n\n    Args:\n        rdf_file_pattern (str): The file pattern to search for RDF files.\n                                A wildcard '*' will be appended if not present.\n        rdf_format (str): The RDF serialization format of the files (default is \"nt\").\n\n    Returns:\n        Graph: The RDF graph populated with data from the files.\n    \"\"\"\n    # Ensure the pattern ends with a wildcard, append if necessary\n    if not rdf_file_pattern.endswith(\"*\"):\n        rdf_file_pattern += \"*\"\n\n    # Find all files matching the pattern\n    rdf_files = glob.glob(rdf_file_pattern)\n\n    # Initialize a new RDF graph\n    g = Graph()\n\n    # Use a progress bar if available or simply iterate over files\n    try:\n        iterator = self.get_progress(rdf_files, desc=\"Loading graph\")\n    except AttributeError:\n        # If get_progress is not defined, fall back to simple iteration\n        iterator = rdf_files\n\n    for rdf_file in iterator:\n        # Parse each RDF file and add it to the graph\n        g.parse(rdf_file, format=rdf_format)\n\n    # After loading all files, return the populated graph\n    return g\n</code></pre>"},{"location":"#frontend.clickstream.ClickstreamManager.serialize_batch","title":"<code>serialize_batch(g, rdf_file, file_counter, rdf_format)</code>","text":"<p>Serializes a batch of RDF data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>g</code> <code>Graph</code> <p>The RDF graph to serialize.</p> required <code>rdf_file</code> <code>str</code> <p>The base name for the RDF file.</p> required <code>file_counter</code> <code>int</code> <p>The current file count for naming.</p> required <code>rdf_format</code> <code>str</code> <p>The format to serialize the RDF data.</p> required Source code in <code>frontend/clickstream.py</code> <pre><code>def serialize_batch(\n    self, g: Graph, rdf_file: str, file_counter: int, rdf_format: str\n) -&gt; None:\n    \"\"\"\n    Serializes a batch of RDF data to a file.\n\n    Args:\n        g (Graph): The RDF graph to serialize.\n        rdf_file (str): The base name for the RDF file.\n        file_counter (int): The current file count for naming.\n        rdf_format (str): The format to serialize the RDF data.\n\n    \"\"\"\n    batch_file = f\"{rdf_file}_part{file_counter:03}.{rdf_format}\"\n    g.serialize(destination=batch_file, format=rdf_format)\n    if self.verbose:\n        print(f\"Exported RDF to {batch_file}\")\n</code></pre>"},{"location":"#frontend.clickstream.DateParse","title":"<code>DateParse</code>","text":"Source code in <code>frontend/clickstream.py</code> <pre><code>class DateParse:\n    @staticmethod\n    def parse_date(date_str: str) -&gt; datetime:\n        \"\"\"Parse a string to a datetime object.\n\n        Args:\n            date_str (str): The date string to parse.\n\n        Returns:\n            datetime: The parsed datetime object.\n        \"\"\"\n        return datetime.strptime(date_str, \"%b %d, %Y %I:%M:%S %p\")\n</code></pre>"},{"location":"#frontend.clickstream.DateParse.parse_date","title":"<code>parse_date(date_str)</code>  <code>staticmethod</code>","text":"<p>Parse a string to a datetime object.</p> <p>Parameters:</p> Name Type Description Default <code>date_str</code> <code>str</code> <p>The date string to parse.</p> required <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The parsed datetime object.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@staticmethod\ndef parse_date(date_str: str) -&gt; datetime:\n    \"\"\"Parse a string to a datetime object.\n\n    Args:\n        date_str (str): The date string to parse.\n\n    Returns:\n        datetime: The parsed datetime object.\n    \"\"\"\n    return datetime.strptime(date_str, \"%b %d, %Y %I:%M:%S %p\")\n</code></pre>"},{"location":"#frontend.clickstream.PageHit","title":"<code>PageHit</code>  <code>dataclass</code>","text":"<p>Represents a single page hit with path and timestamp.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass PageHit:\n    \"\"\"Represents a single page hit with path and timestamp.\"\"\"\n\n    path: str\n    timeStamp: datetime\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"PageHit\":\n        data[\"timeStamp\"] = DateParse.parse_date(data[\"timeStamp\"])\n        return PageHit(**data)\n</code></pre>"},{"location":"#frontend.clickstream.UserAgent","title":"<code>UserAgent</code>  <code>dataclass</code>","text":"<p>Represents a user agent with syntax errors, ambiguity and other attributes.</p> Source code in <code>frontend/clickstream.py</code> <pre><code>@dataclass\nclass UserAgent:\n    \"\"\"Represents a user agent with syntax errors, ambiguity and other attributes.\"\"\"\n\n    hasSyntaxError: bool\n    hasAmbiguity: bool\n    ambiguityCount: int\n    userAgentString: str\n    debug: bool\n    allFields: Dict[str, Dict[str, Any]]\n\n    @staticmethod\n    def from_dict(data: Dict[str, Any]) -&gt; \"UserAgent\":\n        allFields = data.get(\"allFields\", {})\n\n        # Use `.get()` with defaults to prevent KeyError\n        return UserAgent(\n            hasSyntaxError=data.get(\"hasSyntaxError\", False),\n            hasAmbiguity=data.get(\"hasAmbiguity\", False),\n            ambiguityCount=data.get(\"ambiguityCount\", 0),\n            userAgentString=data.get(\"userAgentString\", \"\"),\n            debug=data.get(\"debug\", False),\n            allFields=allFields,\n        )\n</code></pre>"},{"location":"#frontend.cmsmain","title":"<code>cmsmain</code>","text":"<p>Created on 2022-11-24</p> <p>@author: wf</p>"},{"location":"#frontend.cmsmain.CmsMain","title":"<code>CmsMain</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>ContentManagement System Main Program</p> Source code in <code>frontend/cmsmain.py</code> <pre><code>class CmsMain(WebserverCmd):\n    \"\"\"\n    ContentManagement System Main Program\n    \"\"\"\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"--sites\", nargs=\"+\", required=False, help=\"the sites to enable\"\n        )\n        return parser\n</code></pre>"},{"location":"#frontend.cmsmain.CmsMain.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>frontend/cmsmain.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"--sites\", nargs=\"+\", required=False, help=\"the sites to enable\"\n    )\n    return parser\n</code></pre>"},{"location":"#frontend.cmsmain.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>frontend/cmsmain.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = CmsMain(config=CmsWebServer.get_config(), webserver_cls=CmsWebServer)\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#frontend.family","title":"<code>family</code>","text":"<p>Created on 2021-01-01</p> <p>@author: wf</p>"},{"location":"#frontend.family.LocalWiki","title":"<code>LocalWiki</code>","text":"<p>               Bases: <code>object</code></p> <p>a local Wiki</p> Source code in <code>frontend/family.py</code> <pre><code>class LocalWiki(object):\n    \"\"\"\n    a local Wiki\n    \"\"\"\n\n    def __init__(self, siteName: str, family=None, localSettings: str = None):\n        \"\"\"\n        Constructor\n\n        Args:\n            siteName(str): the name of the site\n            localSettings(str): path to the LocalSettings.php (if any)\n        \"\"\"\n        self.siteName = siteName\n        try:\n            self.ip = socket.gethostbyname(self.siteName)\n        except Exception:\n            self.ip = \"?\"\n            pass\n        self.siteId = siteName.split(\".\")[0]\n        self.family = family\n        self.localSettings = localSettings\n        if self.localSettings is None:\n            self.settingLines = []\n        else:\n            with open(localSettings) as f:\n                self.settingLines = f.readlines()\n            self.logo = self.getSetting(\"wgLogo\")\n            self.database = self.getSetting(\"wgDBname\")\n            self.url = self.getSetting(\"wgServer\")\n            self.dbUser = self.getSetting(\"wgDBuser\")\n            self.dbPassword = self.getSetting(\"wgDBpassword\")\n            self.scriptPath = self.getSetting(\"wgScriptPath\")\n            if self.scriptPath is None:\n                self.scriptPath = \"\"\n            self.url = \"%s%s/\" % (self.url, self.scriptPath)\n            self.statusCode = self.getStatusCode()\n\n    def getStatusCode(self, timeout=0.5):\n        \"\"\"\n        get the status Code for my url\n\n        Args:\n            timeout(float): the maximum time to wait for a response\n\n        Returns:\n            int: html statusCode or -1 if there was a timeout\n        \"\"\"\n        statusCode = -1\n        try:\n            page = requests.get(self.url, verify=False, timeout=timeout)\n            statusCode = page.status_code\n        except Exception:\n            pass\n        return statusCode\n\n    def getSetting(self, varName: str) -&gt; str:\n        \"\"\"\n        get the setting of the given variableName from the LocalSettings.php\n\n        Args:\n            varName(str): the name of the variable to return\n        Returns:\n            str: the value of the variable\n        \"\"\"\n        pattern = r'[^#]*\\$%s\\s*=\\s*\"(.*)\"' % varName\n        for line in self.settingLines:\n            m = re.match(pattern, line)\n            if m:\n                value = m.group(1)\n                return value\n        return None\n\n    def getLogo(self) -&gt; str:\n        \"\"\"\n        get the local path to the logo file of this wiki\n\n        Returns:\n            str: the logo path if logo is defined as file else None\n        \"\"\"\n        logoPath = self.logo\n        # work around wgResourceBasePath\n        logoPath = logoPath.replace(\"$wgResourceBasePath\", \"\")\n        logoPath = logoPath.replace(\"/images/%s/\" % self.siteId, \"/images/\")\n        if logoPath.startswith(\"/\") and self.family:\n            logoFile = \"%s/%s%s\" % (self.family.sitedir, self.siteName, logoPath)\n        else:\n            logoFile = None\n        return logoFile\n</code></pre>"},{"location":"#frontend.family.LocalWiki.__init__","title":"<code>__init__(siteName, family=None, localSettings=None)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>siteName(str)</code> <p>the name of the site</p> required <code>localSettings(str)</code> <p>path to the LocalSettings.php (if any)</p> required Source code in <code>frontend/family.py</code> <pre><code>def __init__(self, siteName: str, family=None, localSettings: str = None):\n    \"\"\"\n    Constructor\n\n    Args:\n        siteName(str): the name of the site\n        localSettings(str): path to the LocalSettings.php (if any)\n    \"\"\"\n    self.siteName = siteName\n    try:\n        self.ip = socket.gethostbyname(self.siteName)\n    except Exception:\n        self.ip = \"?\"\n        pass\n    self.siteId = siteName.split(\".\")[0]\n    self.family = family\n    self.localSettings = localSettings\n    if self.localSettings is None:\n        self.settingLines = []\n    else:\n        with open(localSettings) as f:\n            self.settingLines = f.readlines()\n        self.logo = self.getSetting(\"wgLogo\")\n        self.database = self.getSetting(\"wgDBname\")\n        self.url = self.getSetting(\"wgServer\")\n        self.dbUser = self.getSetting(\"wgDBuser\")\n        self.dbPassword = self.getSetting(\"wgDBpassword\")\n        self.scriptPath = self.getSetting(\"wgScriptPath\")\n        if self.scriptPath is None:\n            self.scriptPath = \"\"\n        self.url = \"%s%s/\" % (self.url, self.scriptPath)\n        self.statusCode = self.getStatusCode()\n</code></pre>"},{"location":"#frontend.family.LocalWiki.getLogo","title":"<code>getLogo()</code>","text":"<p>get the local path to the logo file of this wiki</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the logo path if logo is defined as file else None</p> Source code in <code>frontend/family.py</code> <pre><code>def getLogo(self) -&gt; str:\n    \"\"\"\n    get the local path to the logo file of this wiki\n\n    Returns:\n        str: the logo path if logo is defined as file else None\n    \"\"\"\n    logoPath = self.logo\n    # work around wgResourceBasePath\n    logoPath = logoPath.replace(\"$wgResourceBasePath\", \"\")\n    logoPath = logoPath.replace(\"/images/%s/\" % self.siteId, \"/images/\")\n    if logoPath.startswith(\"/\") and self.family:\n        logoFile = \"%s/%s%s\" % (self.family.sitedir, self.siteName, logoPath)\n    else:\n        logoFile = None\n    return logoFile\n</code></pre>"},{"location":"#frontend.family.LocalWiki.getSetting","title":"<code>getSetting(varName)</code>","text":"<p>get the setting of the given variableName from the LocalSettings.php</p> <p>Parameters:</p> Name Type Description Default <code>varName(str)</code> <p>the name of the variable to return</p> required <p>Returns:     str: the value of the variable</p> Source code in <code>frontend/family.py</code> <pre><code>def getSetting(self, varName: str) -&gt; str:\n    \"\"\"\n    get the setting of the given variableName from the LocalSettings.php\n\n    Args:\n        varName(str): the name of the variable to return\n    Returns:\n        str: the value of the variable\n    \"\"\"\n    pattern = r'[^#]*\\$%s\\s*=\\s*\"(.*)\"' % varName\n    for line in self.settingLines:\n        m = re.match(pattern, line)\n        if m:\n            value = m.group(1)\n            return value\n    return None\n</code></pre>"},{"location":"#frontend.family.LocalWiki.getStatusCode","title":"<code>getStatusCode(timeout=0.5)</code>","text":"<p>get the status Code for my url</p> <p>Parameters:</p> Name Type Description Default <code>timeout(float)</code> <p>the maximum time to wait for a response</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>html statusCode or -1 if there was a timeout</p> Source code in <code>frontend/family.py</code> <pre><code>def getStatusCode(self, timeout=0.5):\n    \"\"\"\n    get the status Code for my url\n\n    Args:\n        timeout(float): the maximum time to wait for a response\n\n    Returns:\n        int: html statusCode or -1 if there was a timeout\n    \"\"\"\n    statusCode = -1\n    try:\n        page = requests.get(self.url, verify=False, timeout=timeout)\n        statusCode = page.status_code\n    except Exception:\n        pass\n    return statusCode\n</code></pre>"},{"location":"#frontend.family.WikiBackup","title":"<code>WikiBackup</code>","text":"<p>               Bases: <code>object</code></p> <p>find out details about a WikiBackup</p> <p>potentially this class needs to move upstream to py-3rdparty-MediaWiki</p> Source code in <code>frontend/family.py</code> <pre><code>class WikiBackup(object):\n    \"\"\"\n    find out details about a WikiBackup\n\n    potentially this class needs to move upstream to py-3rdparty-MediaWiki\n    \"\"\"\n\n    def __init__(self, wikiuser):\n        \"\"\"\n        constructor\n\n        Arguments:\n            wikiuser(WikiUser): the wikiuser to access this backup\n        \"\"\"\n        self.wikiuser = wikiuser\n        home = str(Path.home())\n        self.backupPath = f\"{home}/wikibackup/{wikiuser.wikiId}\"\n        self.gitPath = f\"{self.backupPath}/.git\"\n        pass\n\n    def exists(self) -&gt; bool:\n        \"\"\"\n        check if this Backup exists\n\n        Returns:\n            bool: True if the self.backupPath directory exists\n        \"\"\"\n        return os.path.isdir(self.backupPath)\n\n    def hasGit(self) -&gt; bool:\n        \"\"\"\n        check if this Backup has a local git repository\n\n        Returns:\n            bool: True if the self.gitPath directory exists\n        \"\"\"\n        return os.path.isdir(self.gitPath)\n</code></pre>"},{"location":"#frontend.family.WikiBackup.__init__","title":"<code>__init__(wikiuser)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>wikiuser(WikiUser)</code> <p>the wikiuser to access this backup</p> required Source code in <code>frontend/family.py</code> <pre><code>def __init__(self, wikiuser):\n    \"\"\"\n    constructor\n\n    Arguments:\n        wikiuser(WikiUser): the wikiuser to access this backup\n    \"\"\"\n    self.wikiuser = wikiuser\n    home = str(Path.home())\n    self.backupPath = f\"{home}/wikibackup/{wikiuser.wikiId}\"\n    self.gitPath = f\"{self.backupPath}/.git\"\n    pass\n</code></pre>"},{"location":"#frontend.family.WikiBackup.exists","title":"<code>exists()</code>","text":"<p>check if this Backup exists</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the self.backupPath directory exists</p> Source code in <code>frontend/family.py</code> <pre><code>def exists(self) -&gt; bool:\n    \"\"\"\n    check if this Backup exists\n\n    Returns:\n        bool: True if the self.backupPath directory exists\n    \"\"\"\n    return os.path.isdir(self.backupPath)\n</code></pre>"},{"location":"#frontend.family.WikiBackup.hasGit","title":"<code>hasGit()</code>","text":"<p>check if this Backup has a local git repository</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the self.gitPath directory exists</p> Source code in <code>frontend/family.py</code> <pre><code>def hasGit(self) -&gt; bool:\n    \"\"\"\n    check if this Backup has a local git repository\n\n    Returns:\n        bool: True if the self.gitPath directory exists\n    \"\"\"\n    return os.path.isdir(self.gitPath)\n</code></pre>"},{"location":"#frontend.family.WikiFamily","title":"<code>WikiFamily</code>","text":"<p>               Bases: <code>object</code></p> <p>the wiki family found in the given site dir</p> Source code in <code>frontend/family.py</code> <pre><code>class WikiFamily(object):\n    \"\"\"\n    the wiki family found in the given site dir\n    \"\"\"\n\n    def __init__(self, sitedir: str = \"/var/www/mediawiki/sites\"):\n        \"\"\"\n        constructor\n        Args:\n            sitedir(str): the path to the site definitions\n            see http://wiki.bitplan.com/index.php/Wiki_Family\n        \"\"\"\n        self.family = {}\n        self.sitedir = sitedir\n        if os.path.isdir(sitedir):\n            for siteName in os.listdir(sitedir):\n                lsettings = \"%s/%s/LocalSettings.php\" % (sitedir, siteName)\n                if os.path.isfile(lsettings):\n                    localWiki = LocalWiki(siteName, self, lsettings)\n                    self.family[siteName] = localWiki\n</code></pre>"},{"location":"#frontend.family.WikiFamily.__init__","title":"<code>__init__(sitedir='/var/www/mediawiki/sites')</code>","text":"<p>constructor Args:     sitedir(str): the path to the site definitions     see http://wiki.bitplan.com/index.php/Wiki_Family</p> Source code in <code>frontend/family.py</code> <pre><code>def __init__(self, sitedir: str = \"/var/www/mediawiki/sites\"):\n    \"\"\"\n    constructor\n    Args:\n        sitedir(str): the path to the site definitions\n        see http://wiki.bitplan.com/index.php/Wiki_Family\n    \"\"\"\n    self.family = {}\n    self.sitedir = sitedir\n    if os.path.isdir(sitedir):\n        for siteName in os.listdir(sitedir):\n            lsettings = \"%s/%s/LocalSettings.php\" % (sitedir, siteName)\n            if os.path.isfile(lsettings):\n                localWiki = LocalWiki(siteName, self, lsettings)\n                self.family[siteName] = localWiki\n</code></pre>"},{"location":"#frontend.frame","title":"<code>frame</code>","text":""},{"location":"#frontend.frame.HtmlFrame","title":"<code>HtmlFrame</code>","text":"<p>A class to frame html content with a basic HTML document structure.</p> <p>Attributes:</p> Name Type Description <code>lang</code> <code>str</code> <p>Language of the HTML document.</p> <code>title</code> <code>str</code> <p>Title of the HTML document.</p> Source code in <code>frontend/frame.py</code> <pre><code>class HtmlFrame:\n    \"\"\"\n    A class to frame html content with a basic HTML document structure.\n\n    Attributes:\n        lang (str): Language of the HTML document.\n        title (str): Title of the HTML document.\n    \"\"\"\n\n    def __init__(self, frontend, title: str, lang: str = \"en\") -&gt; None:\n        \"\"\"\n        Initialize HtmlFrame with a specified language and title.\n\n        Args:\n            title (str): Title for the HTML document.\n            lang (str, optional): Language of the HTML document. Defaults to \"en\".\n        \"\"\"\n        self.frontend = frontend\n        self.lang = lang\n        self.title = title\n\n    def hamburger_menu(self) -&gt; str:\n        \"\"\"\n        Generate the HTML, CSS, and JavaScript for a hamburger menu.\n\n        Returns:\n            str: Hamburger menu HTML, CSS, and JavaScript.\n        \"\"\"\n        menu_html = \"\"\"\n&lt;!-- Hamburger Menu Start --&gt;\n&lt;style&gt;\n  /* Basic styling */\n  .menu { display: none; }\n  .hamburger { cursor: pointer; }\n  .hamburger:hover { opacity: 0.7; }\n\n  /* Menu items layout */\n  .menu ul { list-style-type: none; padding: 0; }\n  .menu li { padding: 8px; background-color: #f0f0f0; margin-bottom: 5px; }\n\n  /* Show the menu when .show class is added via JavaScript */\n  .show { display: block; }\n&lt;/style&gt;\n\n&lt;!-- Hamburger Icon --&gt;\n&lt;div class=\"hamburger\" onclick=\"toggleMenu()\"&gt;\u2630&lt;/div&gt;\n\n&lt;!-- Menu Items --&gt;\n&lt;div class=\"menu\" id=\"mainMenu\"&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#services\"&gt;Services&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  function toggleMenu() {\n    var menu = document.getElementById(\"mainMenu\");\n    if (menu.classList.contains(\"show\")) {\n      menu.classList.remove(\"show\");\n    } else {\n      menu.classList.add(\"show\");\n    }\n  }\n&lt;/script&gt;\n&lt;!-- Hamburger Menu End --&gt;\n\"\"\"\n        return menu_html\n\n    def header(self) -&gt; str:\n        \"\"\"\n        Generate the header part of the HTML document.\n\n        Returns:\n            str: Header part of an HTML document as a string.\n        \"\"\"\n        style_key = f\"CMS/style\"\n        style_html = self.frontend.cms_pages.get(style_key, \"\")\n        html = f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\"{self.lang}\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"/&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;{self.title}&lt;/title&gt;\n  {style_html}\n&lt;/head&gt;\n&lt;body&gt;  \n\"\"\"\n        return html\n\n    def footer(self) -&gt; str:\n        \"\"\"\n        Generate the footer part of the HTML document.\n\n        Returns:\n            str: Footer part of an HTML document as a string.\n        \"\"\"\n        footer_key = f\"CMS/footer/{self.lang}\"\n        footer_html = self.frontend.cms_pages.get(footer_key, \"\")\n        html = f\"\"\"{footer_html}\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n        return html\n\n    def frame(self, content: str) -&gt; str:\n        \"\"\"\n        Frame the given HTML content with the header and footer of the document.\n\n        Args:\n            content (str): HTML content to be framed within the HTML structure.\n\n        Returns:\n            str: Complete HTML document as a string with the provided content framed.\n        \"\"\"\n        header_key = f\"CMS/header/{self.lang}\"\n        header_html = self.frontend.cms_pages.get(header_key, \"\")\n        html = f\"\"\"{self.header()}\n{self.hamburger_menu()}  \n{header_html}\n      &lt;div class=\"container\"&gt;\n{content}\n      &lt;/div&gt;&lt;!-- /.container --&gt;\n{self.footer()}\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.__init__","title":"<code>__init__(frontend, title, lang='en')</code>","text":"<p>Initialize HtmlFrame with a specified language and title.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Title for the HTML document.</p> required <code>lang</code> <code>str</code> <p>Language of the HTML document. Defaults to \"en\".</p> <code>'en'</code> Source code in <code>frontend/frame.py</code> <pre><code>def __init__(self, frontend, title: str, lang: str = \"en\") -&gt; None:\n    \"\"\"\n    Initialize HtmlFrame with a specified language and title.\n\n    Args:\n        title (str): Title for the HTML document.\n        lang (str, optional): Language of the HTML document. Defaults to \"en\".\n    \"\"\"\n    self.frontend = frontend\n    self.lang = lang\n    self.title = title\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.footer","title":"<code>footer()</code>","text":"<p>Generate the footer part of the HTML document.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Footer part of an HTML document as a string.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def footer(self) -&gt; str:\n        \"\"\"\n        Generate the footer part of the HTML document.\n\n        Returns:\n            str: Footer part of an HTML document as a string.\n        \"\"\"\n        footer_key = f\"CMS/footer/{self.lang}\"\n        footer_html = self.frontend.cms_pages.get(footer_key, \"\")\n        html = f\"\"\"{footer_html}\n  &lt;/body&gt;\n&lt;/html&gt;\n\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.frame","title":"<code>frame(content)</code>","text":"<p>Frame the given HTML content with the header and footer of the document.</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str</code> <p>HTML content to be framed within the HTML structure.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Complete HTML document as a string with the provided content framed.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def frame(self, content: str) -&gt; str:\n        \"\"\"\n        Frame the given HTML content with the header and footer of the document.\n\n        Args:\n            content (str): HTML content to be framed within the HTML structure.\n\n        Returns:\n            str: Complete HTML document as a string with the provided content framed.\n        \"\"\"\n        header_key = f\"CMS/header/{self.lang}\"\n        header_html = self.frontend.cms_pages.get(header_key, \"\")\n        html = f\"\"\"{self.header()}\n{self.hamburger_menu()}  \n{header_html}\n      &lt;div class=\"container\"&gt;\n{content}\n      &lt;/div&gt;&lt;!-- /.container --&gt;\n{self.footer()}\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.hamburger_menu","title":"<code>hamburger_menu()</code>","text":"<p>Generate the HTML, CSS, and JavaScript for a hamburger menu.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Hamburger menu HTML, CSS, and JavaScript.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def hamburger_menu(self) -&gt; str:\n        \"\"\"\n        Generate the HTML, CSS, and JavaScript for a hamburger menu.\n\n        Returns:\n            str: Hamburger menu HTML, CSS, and JavaScript.\n        \"\"\"\n        menu_html = \"\"\"\n&lt;!-- Hamburger Menu Start --&gt;\n&lt;style&gt;\n  /* Basic styling */\n  .menu { display: none; }\n  .hamburger { cursor: pointer; }\n  .hamburger:hover { opacity: 0.7; }\n\n  /* Menu items layout */\n  .menu ul { list-style-type: none; padding: 0; }\n  .menu li { padding: 8px; background-color: #f0f0f0; margin-bottom: 5px; }\n\n  /* Show the menu when .show class is added via JavaScript */\n  .show { display: block; }\n&lt;/style&gt;\n\n&lt;!-- Hamburger Icon --&gt;\n&lt;div class=\"hamburger\" onclick=\"toggleMenu()\"&gt;\u2630&lt;/div&gt;\n\n&lt;!-- Menu Items --&gt;\n&lt;div class=\"menu\" id=\"mainMenu\"&gt;\n  &lt;ul&gt;\n    &lt;li&gt;&lt;a href=\"#home\"&gt;Home&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#about\"&gt;About&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#services\"&gt;Services&lt;/a&gt;&lt;/li&gt;\n    &lt;li&gt;&lt;a href=\"#contact\"&gt;Contact&lt;/a&gt;&lt;/li&gt;\n  &lt;/ul&gt;\n&lt;/div&gt;\n\n&lt;script&gt;\n  function toggleMenu() {\n    var menu = document.getElementById(\"mainMenu\");\n    if (menu.classList.contains(\"show\")) {\n      menu.classList.remove(\"show\");\n    } else {\n      menu.classList.add(\"show\");\n    }\n  }\n&lt;/script&gt;\n&lt;!-- Hamburger Menu End --&gt;\n\"\"\"\n        return menu_html\n</code></pre>"},{"location":"#frontend.frame.HtmlFrame.header","title":"<code>header()</code>","text":"<p>Generate the header part of the HTML document.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Header part of an HTML document as a string.</p> Source code in <code>frontend/frame.py</code> <pre><code>    def header(self) -&gt; str:\n        \"\"\"\n        Generate the header part of the HTML document.\n\n        Returns:\n            str: Header part of an HTML document as a string.\n        \"\"\"\n        style_key = f\"CMS/style\"\n        style_html = self.frontend.cms_pages.get(style_key, \"\")\n        html = f\"\"\"&lt;!doctype html&gt;\n&lt;html lang=\"{self.lang}\"&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"/&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n  &lt;title&gt;{self.title}&lt;/title&gt;\n  {style_html}\n&lt;/head&gt;\n&lt;body&gt;  \n\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.html_table","title":"<code>html_table</code>","text":"<p>Created on 2022-10-25</p> <p>@author: wf</p>"},{"location":"#frontend.html_table.HtmlTables","title":"<code>HtmlTables</code>","text":"<p>               Bases: <code>WebScrape</code></p> <p>HtmlTables extractor</p> Source code in <code>frontend/html_table.py</code> <pre><code>class HtmlTables(WebScrape):\n    \"\"\"\n    HtmlTables extractor\n    \"\"\"\n\n    def __init__(self, url: str, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n\n        url(str): the url to read the tables from\n        debug(bool): if True switch on debugging\n        showHtml(bool): if True show the HTML retrieved\n        \"\"\"\n        super().__init__(debug, showHtml)\n        self.soup = super().getSoup(url, showHtml)\n\n    def get_tables(self, header_tag: str = None) -&gt; dict:\n        \"\"\"\n        get all tables from my soup as a list of list of dicts\n\n        Args:\n            header_tag(str): if set search the table name from the given header tag\n\n        Return:\n            dict: the list of list of dicts for all tables\n\n        \"\"\"\n        tables = {}\n        for i, table in enumerate(self.soup.find_all(\"table\")):\n            fields = []\n            table_data = []\n            category = None\n            for tr in table.find_all(\"tr\", recursive=True):\n                for th in tr.find_all(\"th\", recursive=True):\n                    if \"colspan\" in th.attrs:\n                        category = th.text\n                    else:\n                        fields.append(th.text)\n            for tr in table.find_all(\"tr\", recursive=True):\n                record = {}\n                for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                    record[fields[i]] = td.text\n                if record:\n                    if category:\n                        record[\"category\"] = category\n                    table_data.append(record)\n            if header_tag is not None:\n                header = table.find_previous_sibling(header_tag)\n                table_name = header.text\n            else:\n                table_name = f\"table{i}\"\n            tables[table_name] = table_data\n        return tables\n</code></pre>"},{"location":"#frontend.html_table.HtmlTables.__init__","title":"<code>__init__(url, debug=False, showHtml=False)</code>","text":"<p>Constructor</p> <p>url(str): the url to read the tables from debug(bool): if True switch on debugging showHtml(bool): if True show the HTML retrieved</p> Source code in <code>frontend/html_table.py</code> <pre><code>def __init__(self, url: str, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n\n    url(str): the url to read the tables from\n    debug(bool): if True switch on debugging\n    showHtml(bool): if True show the HTML retrieved\n    \"\"\"\n    super().__init__(debug, showHtml)\n    self.soup = super().getSoup(url, showHtml)\n</code></pre>"},{"location":"#frontend.html_table.HtmlTables.get_tables","title":"<code>get_tables(header_tag=None)</code>","text":"<p>get all tables from my soup as a list of list of dicts</p> <p>Parameters:</p> Name Type Description Default <code>header_tag(str)</code> <p>if set search the table name from the given header tag</p> required Return <p>dict: the list of list of dicts for all tables</p> Source code in <code>frontend/html_table.py</code> <pre><code>def get_tables(self, header_tag: str = None) -&gt; dict:\n    \"\"\"\n    get all tables from my soup as a list of list of dicts\n\n    Args:\n        header_tag(str): if set search the table name from the given header tag\n\n    Return:\n        dict: the list of list of dicts for all tables\n\n    \"\"\"\n    tables = {}\n    for i, table in enumerate(self.soup.find_all(\"table\")):\n        fields = []\n        table_data = []\n        category = None\n        for tr in table.find_all(\"tr\", recursive=True):\n            for th in tr.find_all(\"th\", recursive=True):\n                if \"colspan\" in th.attrs:\n                    category = th.text\n                else:\n                    fields.append(th.text)\n        for tr in table.find_all(\"tr\", recursive=True):\n            record = {}\n            for i, td in enumerate(tr.find_all(\"td\", recursive=True)):\n                record[fields[i]] = td.text\n            if record:\n                if category:\n                    record[\"category\"] = category\n                table_data.append(record)\n        if header_tag is not None:\n            header = table.find_previous_sibling(header_tag)\n            table_name = header.text\n        else:\n            table_name = f\"table{i}\"\n        tables[table_name] = table_data\n    return tables\n</code></pre>"},{"location":"#frontend.server","title":"<code>server</code>","text":"<p>Created on 2021-01-06</p> <p>@author: wf</p>"},{"location":"#frontend.server.Server","title":"<code>Server</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>a server that might serve multiple wikis for a wikiFarm</p> Source code in <code>frontend/server.py</code> <pre><code>class Server(JSONAble):\n    \"\"\"\n    a server that might serve multiple wikis for a wikiFarm\n    \"\"\"\n\n    homePath = None\n\n    def __init__(self, debug=False):\n\n        \"\"\"\n        Constructor\n\n        Args:\n            storePath(str): the path to load my configuration from (if any)\n        \"\"\"\n        self.storage_secret = None\n        self.frontendConfigs = None\n        self.logo = \"https://wiki.bitplan.com/images/wiki/6/63/Profiwikiicon.png\"\n        self.purpose = \"\"\n        self.reinit(debug)\n\n    def reinit(self, debug=False):\n        \"\"\"\n        reinitialize me\n        \"\"\"\n        self.debug = debug\n        self.platform = platform\n        self.uname = os.uname()\n        self.name = self.uname[1]\n        self.hostname = \"?\"\n        self.ip = \"127.0.0.1\"\n        try:\n            self.hostname = socket.getfqdn()\n            self.ip = socket.gethostbyname(self.hostname)\n        except Exception as ex:\n            if self.debug:\n                print(str(ex))\n            pass\n        self.frontends = {}\n        self.siteLookup = {}\n        defaults = {\"sqlBackupPath\": \"/var/backup/sqlbackup\"}\n        for key, value in defaults.items():\n            if not hasattr(self, key):\n                setattr(self, key, value)\n        if Server.homePath is None:\n            self.homePath = str(Path.home())\n        else:\n            self.homePath = Server.homePath\n\n    def sqlGetDatabaseUrl(\n        self, dbname: str, username: str, password: str, hostname: str = None\n    ) -&gt; str:\n        \"\"\"\n        get the DatabaseUrl for the given database Name\n\n        Args:\n            dbname(str): the name of the database\n            username(str): the username\n            password(str): the password\n\n        Returns:\n            str: the url for sqlAlchemy in rfc1738 format e.g. mysql://dt_admin:dt2016@localhost:3308/dreamteam_db\n        \"\"\"\n        # http://docs.sqlalchemy.org/en/latest/dialects/mysql.html\n        if hostname is None:\n            hostname = self.hostname\n        url = \"mysql+pymysql://%s:%s@%s/%s\" % (username, password, hostname, dbname)\n        return url\n\n    def sqlDatabaseExist(\n        self,\n        dburl: str,\n    ) -&gt; bool:\n        \"\"\"\n        check if the database with the given name exists\n\n\n        Args:\n            dburl(str): rfd 1738 formatted database url e.g. mysql://dt_admin:dt2016@localhost:3308/dreamteam_db\n\n        Returns:\n            True if the database exists, else False\n        \"\"\"\n        dbExists = False\n        try:\n            dbExists = database_exists(dburl)\n        except Exception:\n            # bad luck\n            pass\n        return dbExists\n\n    def sqlBackupStateAsHtml(self, dbName):\n        \"\"\"\n        get the backup state of the given sql backup\n\n        Args:\n           dbName(str): the name of the database to check\n\n        Returns:\n            html: backup State html representation\n        \"\"\"\n        backupState = self.sqlBackupState(dbName)\n        mbSize = backupState[\"size\"] / 1024 / 1024\n        mdate = backupState[\"mdate\"]\n        isoDate = mdate.strftime(\"%Y-%m-%d %H:%M:%S\") if mdate else \"\"\n        html = \"%s %s - %4d MB\" % (\n            self.stateSymbol(backupState[\"exists\"]),\n            isoDate,\n            mbSize,\n        )\n        return html\n\n    def sqlBackupState(self, dbName):\n        \"\"\"\n        get the backup state of the given sql backup\n\n        Args:\n           dbName(str): the name of the database to check\n\n        Returns:\n            dict: backup State\n\n        \"\"\"\n        fullBackup = \"%s/today/%s_full.sql\" % (self.sqlBackupPath, dbName)\n        size = 0\n        mdate = None\n        exists = os.path.isfile(fullBackup)\n        if exists:\n            stat = os.stat(fullBackup)\n            size = stat.st_size\n            mtime = stat.st_mtime\n            mdate = datetime.datetime.fromtimestamp(mtime)\n        result = {\"size\": size, \"exists\": exists, \"mdate\": mdate}\n        return result\n\n    def enableFrontend(self, siteName: str, appWrap=None, debug: bool = False):\n        \"\"\"\n        enable the given frontend\n\n        Args:\n            siteName(str): the siteName of the frontend to enable\n            appWrap(appWrap): optional fb4 Application Wrapper\n        Returns:\n            Frontend: the configured frontend\n        \"\"\"\n        if self.frontendConfigs is None:\n            raise Exception(\"No frontend configurations loaded yet\")\n        if siteName not in self.siteLookup:\n            raise Exception(f\"frontend for site {siteName} not configured yet\")\n        frontend = Frontend(siteName)\n        self.frontends[siteName] = frontend\n        config = self.siteLookup[siteName]\n        frontend.site.configure(config)\n        frontend.site.debug = debug\n        frontend.open(appWrap)\n        return frontend\n        pass\n\n    def getFrontend(self, wikiId):\n        \"\"\"\n        get the frontend for the given wikiid\n\n        Args:\n            wikiId(str): the wikiId to get the frontend for\n\n        Returns:\n            Frontend: the frontend for this wikiId\n        \"\"\"\n        return self.frontends[wikiId]\n\n    def load(self):\n        \"\"\"\n        load my front end configurations\n        \"\"\"\n        storePath = self.getStorePath()\n        if os.path.isfile(storePath + \".json\"):\n            self.restoreFromJsonFile(storePath)\n            self.reinit()\n            for config in self.frontendConfigs:\n                siteName = config[\"site\"]\n                self.siteLookup[siteName] = config\n        pass\n\n    def getStorePath(self, prefix: str = \"serverConfig\") -&gt; str:\n        \"\"\"\n        get the path where my store files are located\n        Returns:\n            path to .wikicms in the homedirectory of the current user\n        \"\"\"\n        iniPath = self.homePath + \"/.wikicms\"\n        if not os.path.isdir(iniPath):\n            os.makedirs(iniPath)\n        storePath = f\"{iniPath}/{prefix}\"\n        return storePath\n\n    def store(self):\n        if self.frontends is not None:\n            storePath = self.getStorePath()\n            self.storeToJsonFile(storePath)\n\n    def getPlatformLogo(self) -&gt; str:\n        \"\"\"\n        get the logo url for the platform this server runs on\n\n        Returns:\n            str: the url of the logo for the current operating system platform\n        \"\"\"\n        logos = {\n            \"aix\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/IBM_AIX_logo.svg/200px-IBM_AIX_logo.svg.png\",\n            \"cygwin\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Cygwin_logo.svg/200px-Cygwin_logo.svg.png\",\n            \"darwin\": \"https://upload.wikimedia.org/wikipedia/de/thumb/b/b1/MacOS-Logo.svg/200px-MacOS-Logo.svg.png\",\n            \"linux\": \"https://upload.wikimedia.org/wikipedia/commons/a/af/Tux.png\",\n            \"win32\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Windows_logo_-_2012.svg/200px-Windows_logo_-_2012.svg.png\",\n            \"unknown\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Blue_question_mark.jpg/240px-Blue_question_mark.jpg\",\n        }\n        if self.platform in logos:\n            logo = logos[self.platform]\n        else:\n            logo = logos[\"unknown\"]\n        return logo\n\n    def stateSymbol(self, b: bool) -&gt; str:\n        \"\"\"\n        return the symbol for the given boolean state b\n\n        Args:\n            b(bool): the state to return a symbol for\n\n        Returns:\n            \u2705 for True and \u274c for false\n        \"\"\"\n        symbol = \"\u2705\" if b else \"\u274c\"\n        return symbol\n\n    def checkApacheConfiguration(self, conf, status=\"enabled\") -&gt; str:\n        \"\"\"\n        check the given apache configuration and return an indicator symbol\n\n        Args:\n            conf(str): the name of the apache configuration\n\n        Returns:\n            a state symbol\n        \"\"\"\n        path = f\"/etc/apache2/sites-{status}/{conf}.conf\"\n        confExists = os.path.isfile(path)\n        stateSymbol = self.stateSymbol(confExists)\n        return stateSymbol\n\n    def asHtml(self, logo_size: int = 64) -&gt; str:\n        \"\"\"\n        render me as HTML code\n\n        Args:\n            logo_size(int): the logo_size to apply\u00e5\n        \"\"\"\n        server = self\n        logo_html = \"\"\n        if server.logo is not None:\n            logo_html = f\"\"\"&lt;td&gt;&lt;img src='{server.logo }' alt='{server.name} logo' height='{logo_size}' width='{logo_size}'&gt;&lt;/td&gt;\"\"\"\n        html = f\"\"\"&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;&lt;img src='{server.getPlatformLogo()}' alt='{server.platform} logo' height='{logo_size}' width='{logo_size}'&gt;&lt;/td&gt;\n    {logo_html}\n    &lt;td&gt;&lt;span&gt;Welcome to {server.name } ({ server.ip }) { server.purpose }&lt;/span&gt;&lt;td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.server.Server.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>storePath(str)</code> <p>the path to load my configuration from (if any)</p> required Source code in <code>frontend/server.py</code> <pre><code>def __init__(self, debug=False):\n\n    \"\"\"\n    Constructor\n\n    Args:\n        storePath(str): the path to load my configuration from (if any)\n    \"\"\"\n    self.storage_secret = None\n    self.frontendConfigs = None\n    self.logo = \"https://wiki.bitplan.com/images/wiki/6/63/Profiwikiicon.png\"\n    self.purpose = \"\"\n    self.reinit(debug)\n</code></pre>"},{"location":"#frontend.server.Server.asHtml","title":"<code>asHtml(logo_size=64)</code>","text":"<p>render me as HTML code</p> <p>Parameters:</p> Name Type Description Default <code>logo_size(int)</code> <p>the logo_size to apply\u00e5</p> required Source code in <code>frontend/server.py</code> <pre><code>    def asHtml(self, logo_size: int = 64) -&gt; str:\n        \"\"\"\n        render me as HTML code\n\n        Args:\n            logo_size(int): the logo_size to apply\u00e5\n        \"\"\"\n        server = self\n        logo_html = \"\"\n        if server.logo is not None:\n            logo_html = f\"\"\"&lt;td&gt;&lt;img src='{server.logo }' alt='{server.name} logo' height='{logo_size}' width='{logo_size}'&gt;&lt;/td&gt;\"\"\"\n        html = f\"\"\"&lt;table&gt;\n&lt;tr&gt;\n    &lt;td&gt;&lt;img src='{server.getPlatformLogo()}' alt='{server.platform} logo' height='{logo_size}' width='{logo_size}'&gt;&lt;/td&gt;\n    {logo_html}\n    &lt;td&gt;&lt;span&gt;Welcome to {server.name } ({ server.ip }) { server.purpose }&lt;/span&gt;&lt;td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\"\"\"\n        return html\n</code></pre>"},{"location":"#frontend.server.Server.checkApacheConfiguration","title":"<code>checkApacheConfiguration(conf, status='enabled')</code>","text":"<p>check the given apache configuration and return an indicator symbol</p> <p>Parameters:</p> Name Type Description Default <code>conf(str)</code> <p>the name of the apache configuration</p> required <p>Returns:</p> Type Description <code>str</code> <p>a state symbol</p> Source code in <code>frontend/server.py</code> <pre><code>def checkApacheConfiguration(self, conf, status=\"enabled\") -&gt; str:\n    \"\"\"\n    check the given apache configuration and return an indicator symbol\n\n    Args:\n        conf(str): the name of the apache configuration\n\n    Returns:\n        a state symbol\n    \"\"\"\n    path = f\"/etc/apache2/sites-{status}/{conf}.conf\"\n    confExists = os.path.isfile(path)\n    stateSymbol = self.stateSymbol(confExists)\n    return stateSymbol\n</code></pre>"},{"location":"#frontend.server.Server.enableFrontend","title":"<code>enableFrontend(siteName, appWrap=None, debug=False)</code>","text":"<p>enable the given frontend</p> <p>Parameters:</p> Name Type Description Default <code>siteName(str)</code> <p>the siteName of the frontend to enable</p> required <code>appWrap(appWrap)</code> <p>optional fb4 Application Wrapper</p> required <p>Returns:     Frontend: the configured frontend</p> Source code in <code>frontend/server.py</code> <pre><code>def enableFrontend(self, siteName: str, appWrap=None, debug: bool = False):\n    \"\"\"\n    enable the given frontend\n\n    Args:\n        siteName(str): the siteName of the frontend to enable\n        appWrap(appWrap): optional fb4 Application Wrapper\n    Returns:\n        Frontend: the configured frontend\n    \"\"\"\n    if self.frontendConfigs is None:\n        raise Exception(\"No frontend configurations loaded yet\")\n    if siteName not in self.siteLookup:\n        raise Exception(f\"frontend for site {siteName} not configured yet\")\n    frontend = Frontend(siteName)\n    self.frontends[siteName] = frontend\n    config = self.siteLookup[siteName]\n    frontend.site.configure(config)\n    frontend.site.debug = debug\n    frontend.open(appWrap)\n    return frontend\n    pass\n</code></pre>"},{"location":"#frontend.server.Server.getFrontend","title":"<code>getFrontend(wikiId)</code>","text":"<p>get the frontend for the given wikiid</p> <p>Parameters:</p> Name Type Description Default <code>wikiId(str)</code> <p>the wikiId to get the frontend for</p> required <p>Returns:</p> Name Type Description <code>Frontend</code> <p>the frontend for this wikiId</p> Source code in <code>frontend/server.py</code> <pre><code>def getFrontend(self, wikiId):\n    \"\"\"\n    get the frontend for the given wikiid\n\n    Args:\n        wikiId(str): the wikiId to get the frontend for\n\n    Returns:\n        Frontend: the frontend for this wikiId\n    \"\"\"\n    return self.frontends[wikiId]\n</code></pre>"},{"location":"#frontend.server.Server.getPlatformLogo","title":"<code>getPlatformLogo()</code>","text":"<p>get the logo url for the platform this server runs on</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the url of the logo for the current operating system platform</p> Source code in <code>frontend/server.py</code> <pre><code>def getPlatformLogo(self) -&gt; str:\n    \"\"\"\n    get the logo url for the platform this server runs on\n\n    Returns:\n        str: the url of the logo for the current operating system platform\n    \"\"\"\n    logos = {\n        \"aix\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/IBM_AIX_logo.svg/200px-IBM_AIX_logo.svg.png\",\n        \"cygwin\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Cygwin_logo.svg/200px-Cygwin_logo.svg.png\",\n        \"darwin\": \"https://upload.wikimedia.org/wikipedia/de/thumb/b/b1/MacOS-Logo.svg/200px-MacOS-Logo.svg.png\",\n        \"linux\": \"https://upload.wikimedia.org/wikipedia/commons/a/af/Tux.png\",\n        \"win32\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/5/5f/Windows_logo_-_2012.svg/200px-Windows_logo_-_2012.svg.png\",\n        \"unknown\": \"https://upload.wikimedia.org/wikipedia/commons/thumb/d/d7/Blue_question_mark.jpg/240px-Blue_question_mark.jpg\",\n    }\n    if self.platform in logos:\n        logo = logos[self.platform]\n    else:\n        logo = logos[\"unknown\"]\n    return logo\n</code></pre>"},{"location":"#frontend.server.Server.getStorePath","title":"<code>getStorePath(prefix='serverConfig')</code>","text":"<p>get the path where my store files are located Returns:     path to .wikicms in the homedirectory of the current user</p> Source code in <code>frontend/server.py</code> <pre><code>def getStorePath(self, prefix: str = \"serverConfig\") -&gt; str:\n    \"\"\"\n    get the path where my store files are located\n    Returns:\n        path to .wikicms in the homedirectory of the current user\n    \"\"\"\n    iniPath = self.homePath + \"/.wikicms\"\n    if not os.path.isdir(iniPath):\n        os.makedirs(iniPath)\n    storePath = f\"{iniPath}/{prefix}\"\n    return storePath\n</code></pre>"},{"location":"#frontend.server.Server.load","title":"<code>load()</code>","text":"<p>load my front end configurations</p> Source code in <code>frontend/server.py</code> <pre><code>def load(self):\n    \"\"\"\n    load my front end configurations\n    \"\"\"\n    storePath = self.getStorePath()\n    if os.path.isfile(storePath + \".json\"):\n        self.restoreFromJsonFile(storePath)\n        self.reinit()\n        for config in self.frontendConfigs:\n            siteName = config[\"site\"]\n            self.siteLookup[siteName] = config\n    pass\n</code></pre>"},{"location":"#frontend.server.Server.reinit","title":"<code>reinit(debug=False)</code>","text":"<p>reinitialize me</p> Source code in <code>frontend/server.py</code> <pre><code>def reinit(self, debug=False):\n    \"\"\"\n    reinitialize me\n    \"\"\"\n    self.debug = debug\n    self.platform = platform\n    self.uname = os.uname()\n    self.name = self.uname[1]\n    self.hostname = \"?\"\n    self.ip = \"127.0.0.1\"\n    try:\n        self.hostname = socket.getfqdn()\n        self.ip = socket.gethostbyname(self.hostname)\n    except Exception as ex:\n        if self.debug:\n            print(str(ex))\n        pass\n    self.frontends = {}\n    self.siteLookup = {}\n    defaults = {\"sqlBackupPath\": \"/var/backup/sqlbackup\"}\n    for key, value in defaults.items():\n        if not hasattr(self, key):\n            setattr(self, key, value)\n    if Server.homePath is None:\n        self.homePath = str(Path.home())\n    else:\n        self.homePath = Server.homePath\n</code></pre>"},{"location":"#frontend.server.Server.sqlBackupState","title":"<code>sqlBackupState(dbName)</code>","text":"<p>get the backup state of the given sql backup</p> <p>Parameters:</p> Name Type Description Default <code>dbName(str)</code> <p>the name of the database to check</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>backup State</p> Source code in <code>frontend/server.py</code> <pre><code>def sqlBackupState(self, dbName):\n    \"\"\"\n    get the backup state of the given sql backup\n\n    Args:\n       dbName(str): the name of the database to check\n\n    Returns:\n        dict: backup State\n\n    \"\"\"\n    fullBackup = \"%s/today/%s_full.sql\" % (self.sqlBackupPath, dbName)\n    size = 0\n    mdate = None\n    exists = os.path.isfile(fullBackup)\n    if exists:\n        stat = os.stat(fullBackup)\n        size = stat.st_size\n        mtime = stat.st_mtime\n        mdate = datetime.datetime.fromtimestamp(mtime)\n    result = {\"size\": size, \"exists\": exists, \"mdate\": mdate}\n    return result\n</code></pre>"},{"location":"#frontend.server.Server.sqlBackupStateAsHtml","title":"<code>sqlBackupStateAsHtml(dbName)</code>","text":"<p>get the backup state of the given sql backup</p> <p>Parameters:</p> Name Type Description Default <code>dbName(str)</code> <p>the name of the database to check</p> required <p>Returns:</p> Name Type Description <code>html</code> <p>backup State html representation</p> Source code in <code>frontend/server.py</code> <pre><code>def sqlBackupStateAsHtml(self, dbName):\n    \"\"\"\n    get the backup state of the given sql backup\n\n    Args:\n       dbName(str): the name of the database to check\n\n    Returns:\n        html: backup State html representation\n    \"\"\"\n    backupState = self.sqlBackupState(dbName)\n    mbSize = backupState[\"size\"] / 1024 / 1024\n    mdate = backupState[\"mdate\"]\n    isoDate = mdate.strftime(\"%Y-%m-%d %H:%M:%S\") if mdate else \"\"\n    html = \"%s %s - %4d MB\" % (\n        self.stateSymbol(backupState[\"exists\"]),\n        isoDate,\n        mbSize,\n    )\n    return html\n</code></pre>"},{"location":"#frontend.server.Server.sqlDatabaseExist","title":"<code>sqlDatabaseExist(dburl)</code>","text":"<p>check if the database with the given name exists</p> <p>Parameters:</p> Name Type Description Default <code>dburl(str)</code> <p>rfd 1738 formatted database url e.g. mysql://dt_admin:dt2016@localhost:3308/dreamteam_db</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the database exists, else False</p> Source code in <code>frontend/server.py</code> <pre><code>def sqlDatabaseExist(\n    self,\n    dburl: str,\n) -&gt; bool:\n    \"\"\"\n    check if the database with the given name exists\n\n\n    Args:\n        dburl(str): rfd 1738 formatted database url e.g. mysql://dt_admin:dt2016@localhost:3308/dreamteam_db\n\n    Returns:\n        True if the database exists, else False\n    \"\"\"\n    dbExists = False\n    try:\n        dbExists = database_exists(dburl)\n    except Exception:\n        # bad luck\n        pass\n    return dbExists\n</code></pre>"},{"location":"#frontend.server.Server.sqlGetDatabaseUrl","title":"<code>sqlGetDatabaseUrl(dbname, username, password, hostname=None)</code>","text":"<p>get the DatabaseUrl for the given database Name</p> <p>Parameters:</p> Name Type Description Default <code>dbname(str)</code> <p>the name of the database</p> required <code>username(str)</code> <p>the username</p> required <code>password(str)</code> <p>the password</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the url for sqlAlchemy in rfc1738 format e.g. mysql://dt_admin:dt2016@localhost:3308/dreamteam_db</p> Source code in <code>frontend/server.py</code> <pre><code>def sqlGetDatabaseUrl(\n    self, dbname: str, username: str, password: str, hostname: str = None\n) -&gt; str:\n    \"\"\"\n    get the DatabaseUrl for the given database Name\n\n    Args:\n        dbname(str): the name of the database\n        username(str): the username\n        password(str): the password\n\n    Returns:\n        str: the url for sqlAlchemy in rfc1738 format e.g. mysql://dt_admin:dt2016@localhost:3308/dreamteam_db\n    \"\"\"\n    # http://docs.sqlalchemy.org/en/latest/dialects/mysql.html\n    if hostname is None:\n        hostname = self.hostname\n    url = \"mysql+pymysql://%s:%s@%s/%s\" % (username, password, hostname, dbname)\n    return url\n</code></pre>"},{"location":"#frontend.server.Server.stateSymbol","title":"<code>stateSymbol(b)</code>","text":"<p>return the symbol for the given boolean state b</p> <p>Parameters:</p> Name Type Description Default <code>b(bool)</code> <p>the state to return a symbol for</p> required <p>Returns:</p> Type Description <code>str</code> <p>\u2705 for True and \u274c for false</p> Source code in <code>frontend/server.py</code> <pre><code>def stateSymbol(self, b: bool) -&gt; str:\n    \"\"\"\n    return the symbol for the given boolean state b\n\n    Args:\n        b(bool): the state to return a symbol for\n\n    Returns:\n        \u2705 for True and \u274c for false\n    \"\"\"\n    symbol = \"\u2705\" if b else \"\u274c\"\n    return symbol\n</code></pre>"},{"location":"#frontend.site","title":"<code>site</code>","text":"<p>Created on 2020-12-31</p> <p>@author: wf</p>"},{"location":"#frontend.site.Site","title":"<code>Site</code>","text":"<p>               Bases: <code>object</code></p> <p>migrated from: https://github.com/BITPlan/com.bitplan.wikifrontend/blob/master/src/main/java/com/bitplan/wikifrontend/Site.java</p> Source code in <code>frontend/site.py</code> <pre><code>class Site(object):\n    \"\"\"\n    migrated from:\n    https://github.com/BITPlan/com.bitplan.wikifrontend/blob/master/src/main/java/com/bitplan/wikifrontend/Site.java\n    \"\"\"\n\n    def __init__(\n        self, name: str, defaultPage: str = \"Main Page\", lang: str = \"en\", debug=False\n    ):\n        \"\"\"\n        Constructor\n\n        Args:\n            name(str): the name of this site\n            defaultPage(str): the default Page of this site\n            lang(str): the default language of this site\n            debug(bool): True if debug info should be given\n        \"\"\"\n        self.name = name\n        self.defaultPage = defaultPage\n        self.lang = lang\n        self.configured = False\n        self.debug = debug\n\n    def configure(self, config: dict):\n        \"\"\"\n        configure me from the given configuration\n        Args:\n            config(dict): the configuration to use\n        \"\"\"\n        self.wikiId = config[\"wikiId\"]\n        self.defaultPage = config[\"defaultPage\"]\n        self.configured = True\n\n    def open(self, ws=None):\n        \"\"\"\n        open this site\n\n        Args:\n             ws: Nicegui Webserver\n        \"\"\"\n        if not self.configured:\n            raise Exception(\"need to configure site before opening it\")\n        self.ws = ws\n</code></pre>"},{"location":"#frontend.site.Site.__init__","title":"<code>__init__(name, defaultPage='Main Page', lang='en', debug=False)</code>","text":"<p>Constructor</p> <p>Parameters:</p> Name Type Description Default <code>name(str)</code> <p>the name of this site</p> required <code>defaultPage(str)</code> <p>the default Page of this site</p> required <code>lang(str)</code> <p>the default language of this site</p> required <code>debug(bool)</code> <p>True if debug info should be given</p> required Source code in <code>frontend/site.py</code> <pre><code>def __init__(\n    self, name: str, defaultPage: str = \"Main Page\", lang: str = \"en\", debug=False\n):\n    \"\"\"\n    Constructor\n\n    Args:\n        name(str): the name of this site\n        defaultPage(str): the default Page of this site\n        lang(str): the default language of this site\n        debug(bool): True if debug info should be given\n    \"\"\"\n    self.name = name\n    self.defaultPage = defaultPage\n    self.lang = lang\n    self.configured = False\n    self.debug = debug\n</code></pre>"},{"location":"#frontend.site.Site.configure","title":"<code>configure(config)</code>","text":"<p>configure me from the given configuration Args:     config(dict): the configuration to use</p> Source code in <code>frontend/site.py</code> <pre><code>def configure(self, config: dict):\n    \"\"\"\n    configure me from the given configuration\n    Args:\n        config(dict): the configuration to use\n    \"\"\"\n    self.wikiId = config[\"wikiId\"]\n    self.defaultPage = config[\"defaultPage\"]\n    self.configured = True\n</code></pre>"},{"location":"#frontend.site.Site.open","title":"<code>open(ws=None)</code>","text":"<p>open this site</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <p>Nicegui Webserver</p> <code>None</code> Source code in <code>frontend/site.py</code> <pre><code>def open(self, ws=None):\n    \"\"\"\n    open this site\n\n    Args:\n         ws: Nicegui Webserver\n    \"\"\"\n    if not self.configured:\n        raise Exception(\"need to configure site before opening it\")\n    self.ws = ws\n</code></pre>"},{"location":"#frontend.version","title":"<code>version</code>","text":"<p>Created on 2022-12-03</p> <p>@author: wf</p>"},{"location":"#frontend.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyWikiCMS</p> Source code in <code>frontend/version.py</code> <pre><code>@dataclass\nclass Version(object):\n    \"\"\"\n    Version handling for pyWikiCMS\n    \"\"\"\n\n    name = \"pyWikiCMS\"\n    description = \"pyWikiCMS: python implementation of a Mediawiki based Content Management System\"\n    version = frontend.__version__\n    date = \"2022-11-16\"\n    updated = \"2024-04-17\"\n    authors = \"Wolfgang Fahl\"\n    doc_url = \"http://wiki.bitplan.com/index.php/PyWikiCMS\"\n    chat_url = \"https://github.com/BITPlan/pyWikiCMS/discussions\"\n    cm_url = \"https://github.com/BITPlan/pyWikiCMS\"\n    license = f\"\"\"Copyright 2022-2024 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#frontend.webscrape","title":"<code>webscrape</code>","text":"<p>Created on 2020-08-20</p> <p>@author: wf</p>"},{"location":"#frontend.webscrape.WebScrape","title":"<code>WebScrape</code>","text":"<p>               Bases: <code>object</code></p> <p>WebScraper</p> Source code in <code>frontend/webscrape.py</code> <pre><code>class WebScrape(object):\n    \"\"\"\n    WebScraper\n    \"\"\"\n\n    def __init__(self, debug=False, showHtml=False):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.err = None\n        self.valid = False\n        self.debug = debug\n        self.showHtml = showHtml\n\n    def getSoup(self, url, showHtml):\n        \"\"\"\n        get the beautiful Soup parser\n\n        Args:\n           showHtml(boolean): True if the html code should be pretty printed and shown\n        \"\"\"\n        req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n        html = urlopen(req).read()\n        soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n        if showHtml:\n            self.printPrettyHtml(soup)\n\n        return soup\n\n    def printPrettyHtml(self, soup):\n        \"\"\"\n        print the prettified html for the given soup\n\n        Args:\n            soup(BeuatifulSoup): the parsed html to print\n        \"\"\"\n        prettyHtml = soup.prettify()\n        print(prettyHtml)\n</code></pre>"},{"location":"#frontend.webscrape.WebScrape.__init__","title":"<code>__init__(debug=False, showHtml=False)</code>","text":"<p>Constructor</p> Source code in <code>frontend/webscrape.py</code> <pre><code>def __init__(self, debug=False, showHtml=False):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.err = None\n    self.valid = False\n    self.debug = debug\n    self.showHtml = showHtml\n</code></pre>"},{"location":"#frontend.webscrape.WebScrape.getSoup","title":"<code>getSoup(url, showHtml)</code>","text":"<p>get the beautiful Soup parser</p> <p>Parameters:</p> Name Type Description Default <code>showHtml(boolean)</code> <p>True if the html code should be pretty printed and shown</p> required Source code in <code>frontend/webscrape.py</code> <pre><code>def getSoup(self, url, showHtml):\n    \"\"\"\n    get the beautiful Soup parser\n\n    Args:\n       showHtml(boolean): True if the html code should be pretty printed and shown\n    \"\"\"\n    req = Request(url, headers={\"User-Agent\": \"Mozilla/5.0\"})\n    html = urlopen(req).read()\n    soup = BeautifulSoup(html, \"html.parser\", from_encoding=\"utf-8\")\n    if showHtml:\n        self.printPrettyHtml(soup)\n\n    return soup\n</code></pre>"},{"location":"#frontend.webscrape.WebScrape.printPrettyHtml","title":"<code>printPrettyHtml(soup)</code>","text":"<p>print the prettified html for the given soup</p> <p>Parameters:</p> Name Type Description Default <code>soup(BeuatifulSoup)</code> <p>the parsed html to print</p> required Source code in <code>frontend/webscrape.py</code> <pre><code>def printPrettyHtml(self, soup):\n    \"\"\"\n    print the prettified html for the given soup\n\n    Args:\n        soup(BeuatifulSoup): the parsed html to print\n    \"\"\"\n    prettyHtml = soup.prettify()\n    print(prettyHtml)\n</code></pre>"},{"location":"#frontend.webserver","title":"<code>webserver</code>","text":"<p>Created on 2020-12-30</p> <p>@author: wf</p>"},{"location":"#frontend.webserver.CmsSolution","title":"<code>CmsSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>Content management solution</p> Source code in <code>frontend/webserver.py</code> <pre><code>class CmsSolution(InputWebSolution):\n    \"\"\"\n    Content management solution\n    \"\"\"\n\n    def __init__(self, webserver: CmsWebServer, client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (Cms    WebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.wiki_grid = WikiGrid(self)\n        self.server = webserver.server\n\n    def configure_menu(self):\n        \"\"\"\n        configure specific menu entries\n        \"\"\"\n        username = app.storage.user.get(\"username\", \"?\")\n        ui.label(username)\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n\n        \"\"\"\n\n        def show():\n            with self.content_div:\n                self.server_html = ui.html(self.server.asHtml())\n                self.wiki_grid.setup()\n\n        await self.setup_content_div(show)\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (Cms    WebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>frontend/webserver.py</code> <pre><code>def __init__(self, webserver: CmsWebServer, client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (Cms    WebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.wiki_grid = WikiGrid(self)\n    self.server = webserver.server\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.configure_menu","title":"<code>configure_menu()</code>","text":"<p>configure specific menu entries</p> Source code in <code>frontend/webserver.py</code> <pre><code>def configure_menu(self):\n    \"\"\"\n    configure specific menu entries\n    \"\"\"\n    username = app.storage.user.get(\"username\", \"?\")\n    ui.label(username)\n</code></pre>"},{"location":"#frontend.webserver.CmsSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>frontend/webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n\n    \"\"\"\n\n    def show():\n        with self.content_div:\n            self.server_html = ui.html(self.server.asHtml())\n            self.wiki_grid.setup()\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer","title":"<code>CmsWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>WebServer class that manages the server</p> Source code in <code>frontend/webserver.py</code> <pre><code>class CmsWebServer(InputWebserver):\n    \"\"\"\n    WebServer class that manages the server\n\n    \"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2023-2024 Wolfgang Fahl\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=8252,\n            short_name=\"wikicms\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = CmsSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"\n        constructor\n\n        \"\"\"\n        InputWebserver.__init__(self, config=CmsWebServer.get_config())\n        users = Users(\"~/.wikicms/\")\n        self.login = Login(self, users)\n        self.server = Server()\n        self.server.load()\n        self.enabledSites = [\"admin\"]\n\n        # @ui.page(\"/login\")\n        # async def login(client: Client):\n        #    return await self.page(\n        #        client,CmsSolution.login\n        #    )\n\n        # @ui.page(\"/wikis\")\n        # async def wikis(client: Client):\n        #    if not self.login.authenticated():\n        #        return RedirectResponse(\"/login\")\n        #    return await self.wikis()\n\n        @app.get(\"/{frontend_name}/{page_path:path}\")\n        def render_path(frontend_name: str, page_path: str) -&gt; HTMLResponse:\n            \"\"\"\n            Handles a GET request to render the path of the given frontend.\n\n            Args:\n                frontend_name: The name of the frontend to be rendered.\n                page_path: The specific path within the frontend to be rendered.\n\n            Returns:\n                An HTMLResponse containing the rendered page content.\n\n            \"\"\"\n            return self.render_path(frontend_name, page_path)\n\n    def render_path(self, frontend_name: str, page_path: str):\n        \"\"\"\n        Renders the content for a specific path of the given frontend.\n\n        Args:\n            frontend_name: The name of the frontend to be rendered.\n            page_path: The specific path within the frontend to be rendered.\n\n        Returns:\n            An HTMLResponse containing the rendered page content or an error page if something goes wrong.\n\n        Raises:\n            SomeException: If an error occurs during page content retrieval or rendering.\n\n        \"\"\"\n        frontend = self.server.frontends.get(frontend_name, None)\n        if frontend is None:\n            raise HTTPException(\n                status_code=404, detail=f\"frontend {frontend_name} is not available\"\n            )\n        response = frontend.get_path_response(f\"/{page_path}\")\n        return response\n\n    def enableSites(self, siteNames):\n        \"\"\"\n        enable the sites given in the sites list\n        Args:\n            siteNames(list): a list of strings with wikiIds to be enabled\n        \"\"\"\n        if siteNames is None:\n            return\n        for siteName in siteNames:\n            self.server.enableFrontend(siteName, self)\n            self.enabledSites.append(siteName)\n\n    def configure_run(self):\n        \"\"\"\n        configure command line specific details\n        \"\"\"\n        InputWebserver.configure_run(self)\n        self.enableSites(self.args.sites)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>frontend/webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n\n    \"\"\"\n    InputWebserver.__init__(self, config=CmsWebServer.get_config())\n    users = Users(\"~/.wikicms/\")\n    self.login = Login(self, users)\n    self.server = Server()\n    self.server.load()\n    self.enabledSites = [\"admin\"]\n\n    # @ui.page(\"/login\")\n    # async def login(client: Client):\n    #    return await self.page(\n    #        client,CmsSolution.login\n    #    )\n\n    # @ui.page(\"/wikis\")\n    # async def wikis(client: Client):\n    #    if not self.login.authenticated():\n    #        return RedirectResponse(\"/login\")\n    #    return await self.wikis()\n\n    @app.get(\"/{frontend_name}/{page_path:path}\")\n    def render_path(frontend_name: str, page_path: str) -&gt; HTMLResponse:\n        \"\"\"\n        Handles a GET request to render the path of the given frontend.\n\n        Args:\n            frontend_name: The name of the frontend to be rendered.\n            page_path: The specific path within the frontend to be rendered.\n\n        Returns:\n            An HTMLResponse containing the rendered page content.\n\n        \"\"\"\n        return self.render_path(frontend_name, page_path)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.configure_run","title":"<code>configure_run()</code>","text":"<p>configure command line specific details</p> Source code in <code>frontend/webserver.py</code> <pre><code>def configure_run(self):\n    \"\"\"\n    configure command line specific details\n    \"\"\"\n    InputWebserver.configure_run(self)\n    self.enableSites(self.args.sites)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.enableSites","title":"<code>enableSites(siteNames)</code>","text":"<p>enable the sites given in the sites list Args:     siteNames(list): a list of strings with wikiIds to be enabled</p> Source code in <code>frontend/webserver.py</code> <pre><code>def enableSites(self, siteNames):\n    \"\"\"\n    enable the sites given in the sites list\n    Args:\n        siteNames(list): a list of strings with wikiIds to be enabled\n    \"\"\"\n    if siteNames is None:\n        return\n    for siteName in siteNames:\n        self.server.enableFrontend(siteName, self)\n        self.enabledSites.append(siteName)\n</code></pre>"},{"location":"#frontend.webserver.CmsWebServer.render_path","title":"<code>render_path(frontend_name, page_path)</code>","text":"<p>Renders the content for a specific path of the given frontend.</p> <p>Parameters:</p> Name Type Description Default <code>frontend_name</code> <code>str</code> <p>The name of the frontend to be rendered.</p> required <code>page_path</code> <code>str</code> <p>The specific path within the frontend to be rendered.</p> required <p>Returns:</p> Type Description <p>An HTMLResponse containing the rendered page content or an error page if something goes wrong.</p> <p>Raises:</p> Type Description <code>SomeException</code> <p>If an error occurs during page content retrieval or rendering.</p> Source code in <code>frontend/webserver.py</code> <pre><code>def render_path(self, frontend_name: str, page_path: str):\n    \"\"\"\n    Renders the content for a specific path of the given frontend.\n\n    Args:\n        frontend_name: The name of the frontend to be rendered.\n        page_path: The specific path within the frontend to be rendered.\n\n    Returns:\n        An HTMLResponse containing the rendered page content or an error page if something goes wrong.\n\n    Raises:\n        SomeException: If an error occurs during page content retrieval or rendering.\n\n    \"\"\"\n    frontend = self.server.frontends.get(frontend_name, None)\n    if frontend is None:\n        raise HTTPException(\n            status_code=404, detail=f\"frontend {frontend_name} is not available\"\n        )\n    response = frontend.get_path_response(f\"/{page_path}\")\n    return response\n</code></pre>"},{"location":"#frontend.wikicms","title":"<code>wikicms</code>","text":"<p>Created on 2020-07-27</p> <p>@author: wf</p>"},{"location":"#frontend.wikicms.Frontend","title":"<code>Frontend</code>","text":"<p>               Bases: <code>object</code></p> <p>Wiki Content Management System Frontend</p> Source code in <code>frontend/wikicms.py</code> <pre><code>class Frontend(object):\n    \"\"\"\n    Wiki Content Management System Frontend\n    \"\"\"\n\n    def __init__(\n        self,\n        site_name: str,\n        parser: str = \"lxml\",\n        proxy_prefixes=[\"/images/\", \"/videos\"],\n        debug: bool = False,\n        filterKeys=None,\n    ):\n        \"\"\"\n        Constructor\n        Args:\n            site_name(str): the name of the site this frontend is for\n            parser(str): the beautiful soup parser to use e.g. html.parser\n            proxy_prefixes(list): the list of prefixes that need direct proxy access\n            debug: (bool): True if debugging should be on\n            filterKeys: (list): a list of keys for filters to be applied e.g. editsection\n        \"\"\"\n        self.name = site_name\n        self.parser = parser\n        self.proxy_prefixes = proxy_prefixes\n        self.site = Site(site_name)\n        self.debug = debug\n        self.wiki = None\n        if filterKeys is None:\n            self.filterKeys = [\"editsection\", \"parser-output\", \"parser-output\"]\n        else:\n            self.filterKeys = []\n\n    def log(self, msg):\n        \"\"\"\n        log the given message if debugging is true\n\n        Args:\n            msg(str): the message to log\n        \"\"\"\n        if self.debug:\n            print(msg, flush=True)\n\n    @staticmethod\n    def extract_site_and_path(path):\n        \"\"\"\n        Splits the given path into the site component and the remaining path.\n\n        This static method assumes that the 'site' is the first element of the\n        path when split by \"/\", and the 'path' is the rest of the string after\n        the site.\n\n        Parameters:\n        path (str): The complete path to split.\n\n        Returns:\n        tuple: A tuple where the first element is the site and the second\n               element is the subsequent path.\n        \"\"\"\n        # Check if the path is empty or does not contain a \"/\"\n        if not path or \"/\" not in path:\n            return \"\", path\n\n        # Split the path into parts using the \"/\" as a separator\n        parts = path.split(\"/\")\n\n        # The first part is the site, the rest is joined back into a path\n        site = parts[0]\n        remaining_path = \"/\" + \"/\".join(parts[1:])\n\n        return site, remaining_path\n\n    def open(self, ws=None):\n        \"\"\"\n        open the frontend\n\n        Args:\n             ws: optional Nicegui webserver\n        \"\"\"\n        self.ws = ws\n        if self.wiki is None:\n            self.wiki = WikiClient.ofWikiId(self.site.wikiId)\n            self.wiki.login()\n            self.smwclient = SMWClient(self.wiki.getSite())\n            self.site.open(ws)\n            self.cms_pages = self.get_cms_pages()\n\n    def get_cms_pages(self) -&gt; dict:\n        \"\"\"\n        get the Content Management elements for this site\n        \"\"\"\n        cms_pages = {}\n        ask_query = \"[[Category:CMS]]\"\n        page_records = self.smwclient.query(ask_query, \"cms pages\")\n        for page_title in list(page_records):\n            page_title, html, error = self.getContent(page_title)\n            if not error:\n                cms_pages[page_title] = html\n        return cms_pages\n\n    def errMsg(self, ex):\n        if self.debug:\n            msg = \"%s\\n%s\" % (repr(ex), traceback.format_exc())\n        else:\n            msg = repr(ex)\n        return msg\n\n    def wikiPage(self, pagePath):\n        \"\"\"\n        get the wikiPage for the given pagePath\n\n        Args:\n            pagePath(str): the page path\n        Returns:\n            str: the pageTitle\n        \"\"\"\n        if \"/index.php/\" in pagePath:\n            wikipage = pagePath.replace(\"/index.php/\", \"\")\n        elif pagePath.startswith(\"/\"):\n            wikipage = pagePath[1:]\n        else:\n            wikipage = pagePath\n        return wikipage\n\n    def checkPath(self, pagePath):\n        \"\"\"\n        check the given pathPath\n\n        Args:\n            pagePath(str): the page Path to check\n\n        Returns:\n            str: None or an error message with the illegal chars being used\n        \"\"\"\n        error = None\n        self.log(pagePath)\n        illegalChars = [\"{\", \"}\", \"&lt;\", \"&gt;\", \"[\", \"]\", \"|\"]\n        for illegalChar in illegalChars:\n            if illegalChar in pagePath:\n                error = \"invalid char %s in given pagePath \" % (illegalChar)\n        return error\n\n    def needsProxy(self, path: str) -&gt; bool:\n        \"\"\"\n        Args:\n            path(str): the path to check\n        Returns:\n            True if this path needs to be proxied\n        \"\"\"\n        needs_proxy = False\n        for prefix in self.proxy_prefixes:\n            needs_proxy = needs_proxy or path.startswith(prefix)\n        return needs_proxy\n\n    def proxy(self, path: str) -&gt; str:\n        \"\"\"\n        Proxy a request.\n        See https://stackoverflow.com/a/50231825/1497139\n\n        Args:\n            path (str): the path to proxy\n\n        Returns:\n            the proxied result as a string\n        \"\"\"\n        wikiUser = self.wiki.wikiUser\n        url = f\"{wikiUser.url}{wikiUser.scriptPath}{path}\"\n\n        # Get the response\n        response = requests.get(url)\n\n        return response\n\n    def filter(self, html: str) -&gt; str:\n        \"\"\"\n        filter the given html\n        \"\"\"\n        return self.doFilter(html, self.filterKeys)\n\n    def fixNode(self, node, attribute, prefix, delim=None):\n        \"\"\"\n        fix the given node\n\n        node(BeautifulSoup): the node\n        attribute(str): the name of the attribute e.g. \"href\", \"src\"\n        prefix(str): the prefix to replace e.g. \"/\", \"/images\", \"/thumbs\"\n        delim(str): if not None the delimiter for multiple values\n        \"\"\"\n        siteprefix = f\"/{self.site.name}{prefix}\"\n        if attribute in node.attrs:\n            attrval = node.attrs[attribute]\n            if delim is not None:\n                vals = attrval.split(delim)\n            else:\n                vals = [attrval]\n                delim = \"\"\n            newvals = []\n            for val in vals:\n                if val.startswith(prefix):\n                    newvals.append(val.replace(prefix, siteprefix, 1))\n                else:\n                    newvals.append(val)\n            if delim is not None:\n                node.attrs[attribute] = delim.join(newvals)\n\n    def fix_images_and_videos(self, soup):\n        \"\"\"\n        fix image and video entries in the source code\n        \"\"\"\n        for img in soup.findAll(\"img\"):\n            self.fixNode(img, \"src\", \"/\")\n            self.fixNode(img, \"srcset\", \"/\", \", \")\n        for video in soup.findAll(\"video\"):\n            for source in video.findAll(\"source\"):\n                self.fixNode(source, \"src\", \"/\")\n\n    def fixHtml(self, soup):\n        \"\"\"\n        fix the HTML in the given soup\n\n        Args:\n            soup(BeautifulSoup): the html parser\n        \"\"\"\n        self.fix_images_and_videos(soup)\n        # fix absolute hrefs\n        for a in soup.findAll(\"a\"):\n            self.fixNode(a, \"href\", \"/\")\n        return soup\n\n    def unwrap(self, soup) -&gt; str:\n        \"\"\"\n        unwrap the soup\n        \"\"\"\n        html = str(soup)\n        html = html.replace(\"&lt;html&gt;&lt;body&gt;\", \"\")\n        html = html.replace(\"&lt;/body&gt;&lt;/html&gt;\", \"\")\n        # Remove  empty paragraphs\n        html = re.sub(r'&lt;p class=\"mw-empty-elt\"&gt;\\s*&lt;/p&gt;', \"\", html)\n\n        # Replace multiple newline characters with a single newline character\n        html = re.sub(r\"\\n\\s*\\n\", \"\\n\", html)\n        return html\n\n    def doFilter(self, html, filterKeys):\n        # https://stackoverflow.com/questions/5598524/can-i-remove-script-tags-with-beautifulsoup\n        soup = BeautifulSoup(html, self.parser)\n        if \"parser-output\" in filterKeys:\n            parserdiv = soup.find(\"div\", {\"class\": \"mw-parser-output\"})\n            if parserdiv:\n                soup = parserdiv\n                inner_html = parserdiv.decode_contents()\n                # Parse the inner HTML string to create a new BeautifulSoup object\n                soup = BeautifulSoup(inner_html, self.parser)\n                pass\n        # https://stackoverflow.com/questions/5041008/how-to-find-elements-by-class\n        if \"editsection\" in filterKeys:\n            for s in soup.select(\"span.mw-editsection\"):\n                s.extract()\n        for comments in soup.findAll(text=lambda text: isinstance(text, Comment)):\n            comments.extract()\n        return soup\n\n    def getContent(self, pagePath: str):\n        \"\"\"get the content for the given pagePath\n        Args:\n            pagePath(str): the pagePath\n            whatToFilter(list): list of filter keys\n        Returns:\n            str: the HTML content for the given path\n        \"\"\"\n        content = None\n        error = None\n        pageTitle = \"?\"\n        try:\n            if pagePath == \"/\":\n                pageTitle = self.site.defaultPage\n            else:\n                error = self.checkPath(pagePath)\n                pageTitle = self.wikiPage(pagePath)\n            if error is None:\n                if self.wiki is None:\n                    raise Exception(\n                        \"getContent without wiki - you might want to call open first\"\n                    )\n                content = self.wiki.getHtml(pageTitle)\n                soup = self.filter(content)\n                soup = self.fixHtml(soup)\n                content = self.unwrap(soup)\n        except Exception as e:\n            error = self.errMsg(e)\n        return pageTitle, content, error\n\n    def toReveal(self, html):\n        \"\"\"\n        convert the given html to reveal\n        \"\"\"\n        soup = BeautifulSoup(html, \"lxml\")\n        for h2 in soup.findChildren(recursive=True):\n            if h2.name == \"h2\":\n                span = h2.next_element\n                if span.name == \"span\":\n                    tagid = span.get(\"id\")\n                    if tagid.startswith(\"\u2318\u2318\"):\n                        section = soup.new_tag(\"section\")\n                        h2.parent.append(section)\n                        section.insert(0, h2)\n                        tag = h2.next_element\n                        while tag is not None and tag.name != \"h2\":\n                            if tag.parent != h2:\n                                section.append(tag)\n                            tag = tag.next_element\n        html = self.unwrap(soup)\n        return html\n\n    def get_path_response(self, path: str) -&gt; str:\n        \"\"\"\n        get the repsonse for the the given path\n\n        Args:\n            path(str): the path to render the content for\n\n        Returns:\n            Response: a FastAPI response\n        \"\"\"\n        if self.needsProxy(path):\n            html_response = self.proxy(path)\n            # Create a FastAPI response object\n            response = Response(\n                content=html_response.content,\n                status_code=html_response.status_code,\n                headers=dict(html_response.headers),\n            )\n        else:\n            page_title, content, error = self.getContent(path)\n            frame = HtmlFrame(self, title=page_title)\n            html = content\n            if error:\n                html = f\"error getting {page_title} for {self.name}:&lt;br&gt;{error}\"\n            else:\n                if \"&lt;slideshow\" in html or \"&amp;lt;slideshow\" in html:\n                    content = self.toReveal(content)\n                    html = content\n            framed_html = frame.frame(html)\n            response = HTMLResponse(framed_html)\n        return response\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.__init__","title":"<code>__init__(site_name, parser='lxml', proxy_prefixes=['/images/', '/videos'], debug=False, filterKeys=None)</code>","text":"<p>Constructor Args:     site_name(str): the name of the site this frontend is for     parser(str): the beautiful soup parser to use e.g. html.parser     proxy_prefixes(list): the list of prefixes that need direct proxy access     debug: (bool): True if debugging should be on     filterKeys: (list): a list of keys for filters to be applied e.g. editsection</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def __init__(\n    self,\n    site_name: str,\n    parser: str = \"lxml\",\n    proxy_prefixes=[\"/images/\", \"/videos\"],\n    debug: bool = False,\n    filterKeys=None,\n):\n    \"\"\"\n    Constructor\n    Args:\n        site_name(str): the name of the site this frontend is for\n        parser(str): the beautiful soup parser to use e.g. html.parser\n        proxy_prefixes(list): the list of prefixes that need direct proxy access\n        debug: (bool): True if debugging should be on\n        filterKeys: (list): a list of keys for filters to be applied e.g. editsection\n    \"\"\"\n    self.name = site_name\n    self.parser = parser\n    self.proxy_prefixes = proxy_prefixes\n    self.site = Site(site_name)\n    self.debug = debug\n    self.wiki = None\n    if filterKeys is None:\n        self.filterKeys = [\"editsection\", \"parser-output\", \"parser-output\"]\n    else:\n        self.filterKeys = []\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.checkPath","title":"<code>checkPath(pagePath)</code>","text":"<p>check the given pathPath</p> <p>Parameters:</p> Name Type Description Default <code>pagePath(str)</code> <p>the page Path to check</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>None or an error message with the illegal chars being used</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def checkPath(self, pagePath):\n    \"\"\"\n    check the given pathPath\n\n    Args:\n        pagePath(str): the page Path to check\n\n    Returns:\n        str: None or an error message with the illegal chars being used\n    \"\"\"\n    error = None\n    self.log(pagePath)\n    illegalChars = [\"{\", \"}\", \"&lt;\", \"&gt;\", \"[\", \"]\", \"|\"]\n    for illegalChar in illegalChars:\n        if illegalChar in pagePath:\n            error = \"invalid char %s in given pagePath \" % (illegalChar)\n    return error\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.extract_site_and_path","title":"<code>extract_site_and_path(path)</code>  <code>staticmethod</code>","text":"<p>Splits the given path into the site component and the remaining path.</p> <p>This static method assumes that the 'site' is the first element of the path when split by \"/\", and the 'path' is the rest of the string after the site.</p> <p>Parameters: path (str): The complete path to split.</p> <p>tuple: A tuple where the first element is the site and the second        element is the subsequent path.</p> Source code in <code>frontend/wikicms.py</code> <pre><code>@staticmethod\ndef extract_site_and_path(path):\n    \"\"\"\n    Splits the given path into the site component and the remaining path.\n\n    This static method assumes that the 'site' is the first element of the\n    path when split by \"/\", and the 'path' is the rest of the string after\n    the site.\n\n    Parameters:\n    path (str): The complete path to split.\n\n    Returns:\n    tuple: A tuple where the first element is the site and the second\n           element is the subsequent path.\n    \"\"\"\n    # Check if the path is empty or does not contain a \"/\"\n    if not path or \"/\" not in path:\n        return \"\", path\n\n    # Split the path into parts using the \"/\" as a separator\n    parts = path.split(\"/\")\n\n    # The first part is the site, the rest is joined back into a path\n    site = parts[0]\n    remaining_path = \"/\" + \"/\".join(parts[1:])\n\n    return site, remaining_path\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.filter","title":"<code>filter(html)</code>","text":"<p>filter the given html</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def filter(self, html: str) -&gt; str:\n    \"\"\"\n    filter the given html\n    \"\"\"\n    return self.doFilter(html, self.filterKeys)\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.fixHtml","title":"<code>fixHtml(soup)</code>","text":"<p>fix the HTML in the given soup</p> <p>Parameters:</p> Name Type Description Default <code>soup(BeautifulSoup)</code> <p>the html parser</p> required Source code in <code>frontend/wikicms.py</code> <pre><code>def fixHtml(self, soup):\n    \"\"\"\n    fix the HTML in the given soup\n\n    Args:\n        soup(BeautifulSoup): the html parser\n    \"\"\"\n    self.fix_images_and_videos(soup)\n    # fix absolute hrefs\n    for a in soup.findAll(\"a\"):\n        self.fixNode(a, \"href\", \"/\")\n    return soup\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.fixNode","title":"<code>fixNode(node, attribute, prefix, delim=None)</code>","text":"<p>fix the given node</p> <p>node(BeautifulSoup): the node attribute(str): the name of the attribute e.g. \"href\", \"src\" prefix(str): the prefix to replace e.g. \"/\", \"/images\", \"/thumbs\" delim(str): if not None the delimiter for multiple values</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def fixNode(self, node, attribute, prefix, delim=None):\n    \"\"\"\n    fix the given node\n\n    node(BeautifulSoup): the node\n    attribute(str): the name of the attribute e.g. \"href\", \"src\"\n    prefix(str): the prefix to replace e.g. \"/\", \"/images\", \"/thumbs\"\n    delim(str): if not None the delimiter for multiple values\n    \"\"\"\n    siteprefix = f\"/{self.site.name}{prefix}\"\n    if attribute in node.attrs:\n        attrval = node.attrs[attribute]\n        if delim is not None:\n            vals = attrval.split(delim)\n        else:\n            vals = [attrval]\n            delim = \"\"\n        newvals = []\n        for val in vals:\n            if val.startswith(prefix):\n                newvals.append(val.replace(prefix, siteprefix, 1))\n            else:\n                newvals.append(val)\n        if delim is not None:\n            node.attrs[attribute] = delim.join(newvals)\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.fix_images_and_videos","title":"<code>fix_images_and_videos(soup)</code>","text":"<p>fix image and video entries in the source code</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def fix_images_and_videos(self, soup):\n    \"\"\"\n    fix image and video entries in the source code\n    \"\"\"\n    for img in soup.findAll(\"img\"):\n        self.fixNode(img, \"src\", \"/\")\n        self.fixNode(img, \"srcset\", \"/\", \", \")\n    for video in soup.findAll(\"video\"):\n        for source in video.findAll(\"source\"):\n            self.fixNode(source, \"src\", \"/\")\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.getContent","title":"<code>getContent(pagePath)</code>","text":"<p>get the content for the given pagePath Args:     pagePath(str): the pagePath     whatToFilter(list): list of filter keys Returns:     str: the HTML content for the given path</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def getContent(self, pagePath: str):\n    \"\"\"get the content for the given pagePath\n    Args:\n        pagePath(str): the pagePath\n        whatToFilter(list): list of filter keys\n    Returns:\n        str: the HTML content for the given path\n    \"\"\"\n    content = None\n    error = None\n    pageTitle = \"?\"\n    try:\n        if pagePath == \"/\":\n            pageTitle = self.site.defaultPage\n        else:\n            error = self.checkPath(pagePath)\n            pageTitle = self.wikiPage(pagePath)\n        if error is None:\n            if self.wiki is None:\n                raise Exception(\n                    \"getContent without wiki - you might want to call open first\"\n                )\n            content = self.wiki.getHtml(pageTitle)\n            soup = self.filter(content)\n            soup = self.fixHtml(soup)\n            content = self.unwrap(soup)\n    except Exception as e:\n        error = self.errMsg(e)\n    return pageTitle, content, error\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.get_cms_pages","title":"<code>get_cms_pages()</code>","text":"<p>get the Content Management elements for this site</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def get_cms_pages(self) -&gt; dict:\n    \"\"\"\n    get the Content Management elements for this site\n    \"\"\"\n    cms_pages = {}\n    ask_query = \"[[Category:CMS]]\"\n    page_records = self.smwclient.query(ask_query, \"cms pages\")\n    for page_title in list(page_records):\n        page_title, html, error = self.getContent(page_title)\n        if not error:\n            cms_pages[page_title] = html\n    return cms_pages\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.get_path_response","title":"<code>get_path_response(path)</code>","text":"<p>get the repsonse for the the given path</p> <p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to render the content for</p> required <p>Returns:</p> Name Type Description <code>Response</code> <code>str</code> <p>a FastAPI response</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def get_path_response(self, path: str) -&gt; str:\n    \"\"\"\n    get the repsonse for the the given path\n\n    Args:\n        path(str): the path to render the content for\n\n    Returns:\n        Response: a FastAPI response\n    \"\"\"\n    if self.needsProxy(path):\n        html_response = self.proxy(path)\n        # Create a FastAPI response object\n        response = Response(\n            content=html_response.content,\n            status_code=html_response.status_code,\n            headers=dict(html_response.headers),\n        )\n    else:\n        page_title, content, error = self.getContent(path)\n        frame = HtmlFrame(self, title=page_title)\n        html = content\n        if error:\n            html = f\"error getting {page_title} for {self.name}:&lt;br&gt;{error}\"\n        else:\n            if \"&lt;slideshow\" in html or \"&amp;lt;slideshow\" in html:\n                content = self.toReveal(content)\n                html = content\n        framed_html = frame.frame(html)\n        response = HTMLResponse(framed_html)\n    return response\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.log","title":"<code>log(msg)</code>","text":"<p>log the given message if debugging is true</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to log</p> required Source code in <code>frontend/wikicms.py</code> <pre><code>def log(self, msg):\n    \"\"\"\n    log the given message if debugging is true\n\n    Args:\n        msg(str): the message to log\n    \"\"\"\n    if self.debug:\n        print(msg, flush=True)\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.needsProxy","title":"<code>needsProxy(path)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>path(str)</code> <p>the path to check</p> required <p>Returns:     True if this path needs to be proxied</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def needsProxy(self, path: str) -&gt; bool:\n    \"\"\"\n    Args:\n        path(str): the path to check\n    Returns:\n        True if this path needs to be proxied\n    \"\"\"\n    needs_proxy = False\n    for prefix in self.proxy_prefixes:\n        needs_proxy = needs_proxy or path.startswith(prefix)\n    return needs_proxy\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.open","title":"<code>open(ws=None)</code>","text":"<p>open the frontend</p> <p>Parameters:</p> Name Type Description Default <code>ws</code> <p>optional Nicegui webserver</p> <code>None</code> Source code in <code>frontend/wikicms.py</code> <pre><code>def open(self, ws=None):\n    \"\"\"\n    open the frontend\n\n    Args:\n         ws: optional Nicegui webserver\n    \"\"\"\n    self.ws = ws\n    if self.wiki is None:\n        self.wiki = WikiClient.ofWikiId(self.site.wikiId)\n        self.wiki.login()\n        self.smwclient = SMWClient(self.wiki.getSite())\n        self.site.open(ws)\n        self.cms_pages = self.get_cms_pages()\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.proxy","title":"<code>proxy(path)</code>","text":"<p>Proxy a request. See https://stackoverflow.com/a/50231825/1497139</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>the path to proxy</p> required <p>Returns:</p> Type Description <code>str</code> <p>the proxied result as a string</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def proxy(self, path: str) -&gt; str:\n    \"\"\"\n    Proxy a request.\n    See https://stackoverflow.com/a/50231825/1497139\n\n    Args:\n        path (str): the path to proxy\n\n    Returns:\n        the proxied result as a string\n    \"\"\"\n    wikiUser = self.wiki.wikiUser\n    url = f\"{wikiUser.url}{wikiUser.scriptPath}{path}\"\n\n    # Get the response\n    response = requests.get(url)\n\n    return response\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.toReveal","title":"<code>toReveal(html)</code>","text":"<p>convert the given html to reveal</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def toReveal(self, html):\n    \"\"\"\n    convert the given html to reveal\n    \"\"\"\n    soup = BeautifulSoup(html, \"lxml\")\n    for h2 in soup.findChildren(recursive=True):\n        if h2.name == \"h2\":\n            span = h2.next_element\n            if span.name == \"span\":\n                tagid = span.get(\"id\")\n                if tagid.startswith(\"\u2318\u2318\"):\n                    section = soup.new_tag(\"section\")\n                    h2.parent.append(section)\n                    section.insert(0, h2)\n                    tag = h2.next_element\n                    while tag is not None and tag.name != \"h2\":\n                        if tag.parent != h2:\n                            section.append(tag)\n                        tag = tag.next_element\n    html = self.unwrap(soup)\n    return html\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.unwrap","title":"<code>unwrap(soup)</code>","text":"<p>unwrap the soup</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def unwrap(self, soup) -&gt; str:\n    \"\"\"\n    unwrap the soup\n    \"\"\"\n    html = str(soup)\n    html = html.replace(\"&lt;html&gt;&lt;body&gt;\", \"\")\n    html = html.replace(\"&lt;/body&gt;&lt;/html&gt;\", \"\")\n    # Remove  empty paragraphs\n    html = re.sub(r'&lt;p class=\"mw-empty-elt\"&gt;\\s*&lt;/p&gt;', \"\", html)\n\n    # Replace multiple newline characters with a single newline character\n    html = re.sub(r\"\\n\\s*\\n\", \"\\n\", html)\n    return html\n</code></pre>"},{"location":"#frontend.wikicms.Frontend.wikiPage","title":"<code>wikiPage(pagePath)</code>","text":"<p>get the wikiPage for the given pagePath</p> <p>Parameters:</p> Name Type Description Default <code>pagePath(str)</code> <p>the page path</p> required <p>Returns:     str: the pageTitle</p> Source code in <code>frontend/wikicms.py</code> <pre><code>def wikiPage(self, pagePath):\n    \"\"\"\n    get the wikiPage for the given pagePath\n\n    Args:\n        pagePath(str): the page path\n    Returns:\n        str: the pageTitle\n    \"\"\"\n    if \"/index.php/\" in pagePath:\n        wikipage = pagePath.replace(\"/index.php/\", \"\")\n    elif pagePath.startswith(\"/\"):\n        wikipage = pagePath[1:]\n    else:\n        wikipage = pagePath\n    return wikipage\n</code></pre>"},{"location":"#frontend.wikigrid","title":"<code>wikigrid</code>","text":"<p>Created on 2022-12-03</p> <p>@author: wf</p>"},{"location":"#frontend.wikigrid.WikiCheck","title":"<code>WikiCheck</code>","text":"<p>A check for a Mediawiki.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>class WikiCheck:\n    \"\"\"\n    A check for a Mediawiki.\n    \"\"\"\n\n    def __init__(self, name, func, checked=True):\n        self.name = name\n        self.func = func  # the check function to be performed on a WikiState\n        self.checked = checked\n        self.checkbox = None\n\n    def as_checkbox(self):\n        \"\"\"\n        Return a checkbox representation of the instance.\n        \"\"\"\n        self.checkbox = ui.checkbox(self.name).bind_value(self, \"checked\")\n        return self.checkbox\n</code></pre>"},{"location":"#frontend.wikigrid.WikiCheck.as_checkbox","title":"<code>as_checkbox()</code>","text":"<p>Return a checkbox representation of the instance.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def as_checkbox(self):\n    \"\"\"\n    Return a checkbox representation of the instance.\n    \"\"\"\n    self.checkbox = ui.checkbox(self.name).bind_value(self, \"checked\")\n    return self.checkbox\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid","title":"<code>WikiGrid</code>","text":"<p>A grid of Wikis.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>class WikiGrid:\n    \"\"\"\n    A grid of Wikis.\n    \"\"\"\n\n    def __init__(self, solution):\n        # back reference to nicegui solution\n        self.solution = solution\n\n        self.wiki_users = WikiUser.getWikiUsers()\n        self.wiki_clients = {}\n        self.smw_clients = {}\n        self.sorted_wiki_users = sorted(\n            self.wiki_users.values(), key=lambda w: w.wikiId\n        )\n        self.lod = []\n        self.wikistates_by_row_no = {}\n        for index, wiki_user in enumerate(self.sorted_wiki_users):\n            wiki_state = WikiState(index, wiki_user)\n            record = wiki_state.as_dict()\n            self.lod.append(record)\n            self.wikistates_by_row_no[wiki_state.row_no] = wiki_state\n\n    def setup(self):\n        self.add_checkboxes()\n        self.progressbar = NiceguiProgressbar(\n            len(self.wikistates_by_row_no), \"work on wikis\", \"steps\"\n        )\n        self.as_grid()\n        self.lod_grid.update()\n\n    def as_grid(self):\n        self.lod_grid = ListOfDictsGrid(lod=self.lod)\n        self.lod_grid.ag_grid._props[\"html_columns\"] = [0, 1, 2]\n        return self.lod_grid\n\n    def add_checkboxes(self):\n        \"\"\"\n        Add check boxes.\n        \"\"\"\n        self.wiki_checks = [\n            WikiCheck(\"version\", self.check_wiki_version),\n            WikiCheck(\"backup\", self.check_backup),\n            WikiCheck(\"pages\", self.check_pages),\n        ]\n        for wiki_check in self.wiki_checks:\n            wiki_check.as_checkbox()\n        ui.button(text=\"Checks\", on_click=self.perform_wiki_checks)\n\n    def check_version(self, wiki_url):\n        \"\"\"\n        Check the MediaWiki version.\n        \"\"\"\n        version_url = f\"{wiki_url}/index.php/Special:Version\"\n        mw_version = \"?\"\n        try:\n            html_tables = HtmlTables(version_url)\n            tables = html_tables.get_tables(\"h2\")\n            if \"Installed software\" in tables:\n                software = tables[\"Installed software\"]\n                software_map, _dup = LOD.getLookup(\n                    software, \"Product\", withDuplicates=False\n                )\n                mw_version = software_map[\"MediaWiki\"][\"Version\"]\n        except Exception as ex:\n            mw_version = f\"error: {str(ex)}\"\n        return mw_version\n\n    async def perform_wiki_checks(self, _msg):\n        await run.io_bound(self.run_wiki_checks)\n\n    def run_wiki_checks(self):\n        \"\"\"\n        perform the selected wiki checks\n        \"\"\"\n        with self.solution.content_div:\n            ui.notify(f\"Checking {len(self.wikistates_by_row_no)} wikis ...\")\n        progress_bar = self.progressbar\n        try:\n            with self.solution.content_div:\n                progress_bar.reset()\n            for wiki_state in self.wikistates_by_row_no.values():\n                for wiki_check in self.wiki_checks:\n                    if wiki_check.checked:\n                        wiki_check.func(wiki_state)\n                    with self.solution.content_div:\n                        self.lod_grid.update()\n                        # Update the progress bar\n                        progress_bar.update(1)\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def check_pages(self, wiki_state):\n        \"\"\"\n        Try login for wiki user and report success or failure.\n        \"\"\"\n        try:\n            wiki_state.wiki_client = WikiClient.ofWikiUser(wiki_state.wiki_user)\n            try:\n                wiki_state.wiki_client.login()\n                stats = wiki_state.wiki_client.get_site_statistics()\n                pages = stats[\"pages\"]\n                self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u2705\")\n                self.lod_grid.update_cell(wiki_state.row_no, \"pages\", f\"\u2705{pages}\")\n            except Exception as ex:\n                self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u274c {str(ex)}\")\n                self.lod_grid.update_cell(wiki_state.row_no, \"pages\", \"\u274c\")\n                return\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def check_wiki_version(self, wiki_state):\n        \"\"\"\n        Check the MediaWiki version for a specific WikiState.\n        \"\"\"\n        try:\n            wiki_url = wiki_state.wiki_user.getWikiUrl()\n            mw_version = self.check_version(wiki_url)\n            if not mw_version.startswith(\"MediaWiki\"):\n                mw_version = f\"MediaWiki {mw_version}\"\n            row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n            if row:\n                ex_version = row[\"version\"]\n                if ex_version == mw_version:\n                    self.lod_grid.update_cell(\n                        wiki_state.row_no, \"version\", f\"{mw_version}\u2705\"\n                    )\n                else:\n                    self.lod_grid.update_cell(\n                        wiki_state.row_no, \"version\", f\"{ex_version}!={mw_version}\u274c\"\n                    )\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def check_backup(self, wiki_state):\n        \"\"\"\n        Check the backup status for a specific WikiUser.\n        \"\"\"\n        try:\n            row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n            if row:\n                backup_path = f\"{Path.home()}/wikibackup/{wiki_state.wiki_user.wikiId}\"\n                if os.path.isdir(backup_path):\n                    wiki_files = glob.glob(f\"{backup_path}/*.wiki\")\n                    msg = f\"{len(wiki_files):6} \u2705\"\n                    self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n                    # https://stackoverflow.com/a/39327156/1497139\n                    if wiki_files:\n                        latest_file = max(wiki_files, key=os.path.getctime)\n                        st = os.stat(latest_file)\n                        age_days = round((time.time() - st.st_mtime) / 86400)\n                        self.lod_grid.update_cell(\n                            wiki_state.row_no, \"age\", f\"{age_days}\"\n                        )\n                else:\n                    msg = \"\u274c\"\n                    self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.add_checkboxes","title":"<code>add_checkboxes()</code>","text":"<p>Add check boxes.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def add_checkboxes(self):\n    \"\"\"\n    Add check boxes.\n    \"\"\"\n    self.wiki_checks = [\n        WikiCheck(\"version\", self.check_wiki_version),\n        WikiCheck(\"backup\", self.check_backup),\n        WikiCheck(\"pages\", self.check_pages),\n    ]\n    for wiki_check in self.wiki_checks:\n        wiki_check.as_checkbox()\n    ui.button(text=\"Checks\", on_click=self.perform_wiki_checks)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_backup","title":"<code>check_backup(wiki_state)</code>","text":"<p>Check the backup status for a specific WikiUser.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_backup(self, wiki_state):\n    \"\"\"\n    Check the backup status for a specific WikiUser.\n    \"\"\"\n    try:\n        row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n        if row:\n            backup_path = f\"{Path.home()}/wikibackup/{wiki_state.wiki_user.wikiId}\"\n            if os.path.isdir(backup_path):\n                wiki_files = glob.glob(f\"{backup_path}/*.wiki\")\n                msg = f\"{len(wiki_files):6} \u2705\"\n                self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n                # https://stackoverflow.com/a/39327156/1497139\n                if wiki_files:\n                    latest_file = max(wiki_files, key=os.path.getctime)\n                    st = os.stat(latest_file)\n                    age_days = round((time.time() - st.st_mtime) / 86400)\n                    self.lod_grid.update_cell(\n                        wiki_state.row_no, \"age\", f\"{age_days}\"\n                    )\n            else:\n                msg = \"\u274c\"\n                self.lod_grid.update_cell(wiki_state.row_no, \"backup\", msg)\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_pages","title":"<code>check_pages(wiki_state)</code>","text":"<p>Try login for wiki user and report success or failure.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_pages(self, wiki_state):\n    \"\"\"\n    Try login for wiki user and report success or failure.\n    \"\"\"\n    try:\n        wiki_state.wiki_client = WikiClient.ofWikiUser(wiki_state.wiki_user)\n        try:\n            wiki_state.wiki_client.login()\n            stats = wiki_state.wiki_client.get_site_statistics()\n            pages = stats[\"pages\"]\n            self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u2705\")\n            self.lod_grid.update_cell(wiki_state.row_no, \"pages\", f\"\u2705{pages}\")\n        except Exception as ex:\n            self.lod_grid.update_cell(wiki_state.row_no, \"login\", f\"\u274c {str(ex)}\")\n            self.lod_grid.update_cell(wiki_state.row_no, \"pages\", \"\u274c\")\n            return\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_version","title":"<code>check_version(wiki_url)</code>","text":"<p>Check the MediaWiki version.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_version(self, wiki_url):\n    \"\"\"\n    Check the MediaWiki version.\n    \"\"\"\n    version_url = f\"{wiki_url}/index.php/Special:Version\"\n    mw_version = \"?\"\n    try:\n        html_tables = HtmlTables(version_url)\n        tables = html_tables.get_tables(\"h2\")\n        if \"Installed software\" in tables:\n            software = tables[\"Installed software\"]\n            software_map, _dup = LOD.getLookup(\n                software, \"Product\", withDuplicates=False\n            )\n            mw_version = software_map[\"MediaWiki\"][\"Version\"]\n    except Exception as ex:\n        mw_version = f\"error: {str(ex)}\"\n    return mw_version\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.check_wiki_version","title":"<code>check_wiki_version(wiki_state)</code>","text":"<p>Check the MediaWiki version for a specific WikiState.</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def check_wiki_version(self, wiki_state):\n    \"\"\"\n    Check the MediaWiki version for a specific WikiState.\n    \"\"\"\n    try:\n        wiki_url = wiki_state.wiki_user.getWikiUrl()\n        mw_version = self.check_version(wiki_url)\n        if not mw_version.startswith(\"MediaWiki\"):\n            mw_version = f\"MediaWiki {mw_version}\"\n        row = self.lod_grid.get_row_for_key(wiki_state.row_no)\n        if row:\n            ex_version = row[\"version\"]\n            if ex_version == mw_version:\n                self.lod_grid.update_cell(\n                    wiki_state.row_no, \"version\", f\"{mw_version}\u2705\"\n                )\n            else:\n                self.lod_grid.update_cell(\n                    wiki_state.row_no, \"version\", f\"{ex_version}!={mw_version}\u274c\"\n                )\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiGrid.run_wiki_checks","title":"<code>run_wiki_checks()</code>","text":"<p>perform the selected wiki checks</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def run_wiki_checks(self):\n    \"\"\"\n    perform the selected wiki checks\n    \"\"\"\n    with self.solution.content_div:\n        ui.notify(f\"Checking {len(self.wikistates_by_row_no)} wikis ...\")\n    progress_bar = self.progressbar\n    try:\n        with self.solution.content_div:\n            progress_bar.reset()\n        for wiki_state in self.wikistates_by_row_no.values():\n            for wiki_check in self.wiki_checks:\n                if wiki_check.checked:\n                    wiki_check.func(wiki_state)\n                with self.solution.content_div:\n                    self.lod_grid.update()\n                    # Update the progress bar\n                    progress_bar.update(1)\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#frontend.wikigrid.WikiState","title":"<code>WikiState</code>","text":"<p>the state of a wiki</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>class WikiState:\n    \"\"\"\n    the state of a wiki\n    \"\"\"\n\n    def __init__(self, row_index, wiki_user):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.row_no = row_index + 1\n        self.wiki_user = wiki_user\n        self.wiki_backup = WikiBackup(wiki_user)\n\n    def as_dict(self):\n        url = f\"{self.wiki_user.url}{self.wiki_user.scriptPath}\"\n        link = Link.create(url=url, text=self.wiki_user.wikiId, target=\"_blank\")\n\n        record = {\n            \"#\": self.row_no,\n            \"wiki\": link,\n            \"version\": self.wiki_user.version,\n            \"pages\": \"\",\n            \"backup\": \"\u2705\" if self.wiki_backup.exists() else \"\u274c\",\n            \"git\": \"\u2705\" if self.wiki_backup.hasGit() else \"\u274c\",\n            \"age\": \"\",\n            \"login\": \"\",\n        }\n        return record\n</code></pre>"},{"location":"#frontend.wikigrid.WikiState.__init__","title":"<code>__init__(row_index, wiki_user)</code>","text":"<p>constructor</p> Source code in <code>frontend/wikigrid.py</code> <pre><code>def __init__(self, row_index, wiki_user):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.row_no = row_index + 1\n    self.wiki_user = wiki_user\n    self.wiki_backup = WikiBackup(wiki_user)\n</code></pre>"}]}